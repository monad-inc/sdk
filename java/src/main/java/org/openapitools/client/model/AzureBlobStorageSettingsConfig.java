/*
 * Monad API
 * This is the monad API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * AzureBlobStorageSettingsConfig
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2026-02-03T01:24:05.942842860Z[Etc/UTC]", comments = "Generator version: 7.19.0")
public class AzureBlobStorageSettingsConfig {
  public static final String SERIALIZED_NAME_ACCOUNT_URL = "account_url";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_URL)
  @javax.annotation.Nullable
  private String accountUrl;

  public static final String SERIALIZED_NAME_BACKFILL_START_TIME = "backfill_start_time";
  @SerializedName(SERIALIZED_NAME_BACKFILL_START_TIME)
  @javax.annotation.Nullable
  private String backfillStartTime;

  public static final String SERIALIZED_NAME_COMPRESSION = "compression";
  @SerializedName(SERIALIZED_NAME_COMPRESSION)
  @javax.annotation.Nullable
  private String compression;

  public static final String SERIALIZED_NAME_CONTAINER = "container";
  @SerializedName(SERIALIZED_NAME_CONTAINER)
  @javax.annotation.Nullable
  private String container;

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  @javax.annotation.Nullable
  private String format;

  public static final String SERIALIZED_NAME_PARTITION_FORMAT = "partition_format";
  @SerializedName(SERIALIZED_NAME_PARTITION_FORMAT)
  @javax.annotation.Nullable
  private String partitionFormat;

  public static final String SERIALIZED_NAME_PREFIX = "prefix";
  @SerializedName(SERIALIZED_NAME_PREFIX)
  @javax.annotation.Nullable
  private String prefix;

  public static final String SERIALIZED_NAME_RECORD_LOCATION = "record_location";
  @SerializedName(SERIALIZED_NAME_RECORD_LOCATION)
  @javax.annotation.Nullable
  private String recordLocation;

  public AzureBlobStorageSettingsConfig() {
  }

  public AzureBlobStorageSettingsConfig accountUrl(@javax.annotation.Nullable String accountUrl) {
    this.accountUrl = accountUrl;
    return this;
  }

  /**
   * Represents your storage account in Azure. Typically of the format https://{account}.blob.core.windows.net.
   * @return accountUrl
   */
  @javax.annotation.Nullable
  public String getAccountUrl() {
    return accountUrl;
  }

  public void setAccountUrl(@javax.annotation.Nullable String accountUrl) {
    this.accountUrl = accountUrl;
  }


  public AzureBlobStorageSettingsConfig backfillStartTime(@javax.annotation.Nullable String backfillStartTime) {
    this.backfillStartTime = backfillStartTime;
    return this;
  }

  /**
   * Starting timestamp for initial data sync. Only processes blobs with a last modified time after this timestamp on the initial sync. If not specified, all available data from the specified prefix will be processed. Incremental syncs automatically continue from the last processed timestamp, scanning from the previous day&#39;s partition forward to catch late-arriving data. Files updated in partitions older than the current state&#39;s previous prefix will not be detected.
   * @return backfillStartTime
   */
  @javax.annotation.Nullable
  public String getBackfillStartTime() {
    return backfillStartTime;
  }

  public void setBackfillStartTime(@javax.annotation.Nullable String backfillStartTime) {
    this.backfillStartTime = backfillStartTime;
  }


  public AzureBlobStorageSettingsConfig compression(@javax.annotation.Nullable String compression) {
    this.compression = compression;
    return this;
  }

  /**
   * The compression format of objects in the Azure container
   * @return compression
   */
  @javax.annotation.Nullable
  public String getCompression() {
    return compression;
  }

  public void setCompression(@javax.annotation.Nullable String compression) {
    this.compression = compression;
  }


  public AzureBlobStorageSettingsConfig container(@javax.annotation.Nullable String container) {
    this.container = container;
    return this;
  }

  /**
   * A container organizes a set of blobs, similar to a directory in a file system.
   * @return container
   */
  @javax.annotation.Nullable
  public String getContainer() {
    return container;
  }

  public void setContainer(@javax.annotation.Nullable String container) {
    this.container = container;
  }


  public AzureBlobStorageSettingsConfig format(@javax.annotation.Nullable String format) {
    this.format = format;
    return this;
  }

  /**
   * File format of the Blob storage objects in Azure.
   * @return format
   */
  @javax.annotation.Nullable
  public String getFormat() {
    return format;
  }

  public void setFormat(@javax.annotation.Nullable String format) {
    this.format = format;
  }


  public AzureBlobStorageSettingsConfig partitionFormat(@javax.annotation.Nullable String partitionFormat) {
    this.partitionFormat = partitionFormat;
    return this;
  }

  /**
   * Specifies the format for organizing data into partitions within your Azure container. This determines the directory structure and naming convention for stored objects, affecting data organization and query efficiency. Examples include Hive-style partitioning (e.g., &#39;year&#x3D;2024/month&#x3D;01/day&#x3D;01&#39;) and simple date-based formats (e.g., &#39;2024/01/01&#39;).
   * @return partitionFormat
   */
  @javax.annotation.Nullable
  public String getPartitionFormat() {
    return partitionFormat;
  }

  public void setPartitionFormat(@javax.annotation.Nullable String partitionFormat) {
    this.partitionFormat = partitionFormat;
  }


  public AzureBlobStorageSettingsConfig prefix(@javax.annotation.Nullable String prefix) {
    this.prefix = prefix;
    return this;
  }

  /**
   * An optional prefix for Azure object keys to organize data within the container
   * @return prefix
   */
  @javax.annotation.Nullable
  public String getPrefix() {
    return prefix;
  }

  public void setPrefix(@javax.annotation.Nullable String prefix) {
    this.prefix = prefix;
  }


  public AzureBlobStorageSettingsConfig recordLocation(@javax.annotation.Nullable String recordLocation) {
    this.recordLocation = recordLocation;
    return this;
  }

  /**
   * Location of the record in the JSON object. Applies only if the format is JSON.
   * @return recordLocation
   */
  @javax.annotation.Nullable
  public String getRecordLocation() {
    return recordLocation;
  }

  public void setRecordLocation(@javax.annotation.Nullable String recordLocation) {
    this.recordLocation = recordLocation;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AzureBlobStorageSettingsConfig azureBlobStorageSettingsConfig = (AzureBlobStorageSettingsConfig) o;
    return Objects.equals(this.accountUrl, azureBlobStorageSettingsConfig.accountUrl) &&
        Objects.equals(this.backfillStartTime, azureBlobStorageSettingsConfig.backfillStartTime) &&
        Objects.equals(this.compression, azureBlobStorageSettingsConfig.compression) &&
        Objects.equals(this.container, azureBlobStorageSettingsConfig.container) &&
        Objects.equals(this.format, azureBlobStorageSettingsConfig.format) &&
        Objects.equals(this.partitionFormat, azureBlobStorageSettingsConfig.partitionFormat) &&
        Objects.equals(this.prefix, azureBlobStorageSettingsConfig.prefix) &&
        Objects.equals(this.recordLocation, azureBlobStorageSettingsConfig.recordLocation);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountUrl, backfillStartTime, compression, container, format, partitionFormat, prefix, recordLocation);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AzureBlobStorageSettingsConfig {\n");
    sb.append("    accountUrl: ").append(toIndentedString(accountUrl)).append("\n");
    sb.append("    backfillStartTime: ").append(toIndentedString(backfillStartTime)).append("\n");
    sb.append("    compression: ").append(toIndentedString(compression)).append("\n");
    sb.append("    container: ").append(toIndentedString(container)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    partitionFormat: ").append(toIndentedString(partitionFormat)).append("\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    recordLocation: ").append(toIndentedString(recordLocation)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("account_url", "backfill_start_time", "compression", "container", "format", "partition_format", "prefix", "record_location"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AzureBlobStorageSettingsConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AzureBlobStorageSettingsConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "The required field(s) %s in AzureBlobStorageSettingsConfig is not found in the empty JSON string", AzureBlobStorageSettingsConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AzureBlobStorageSettingsConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "The field `%s` in the JSON string is not defined in the `AzureBlobStorageSettingsConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("account_url") != null && !jsonObj.get("account_url").isJsonNull()) && !jsonObj.get("account_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `account_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("account_url").toString()));
      }
      if ((jsonObj.get("backfill_start_time") != null && !jsonObj.get("backfill_start_time").isJsonNull()) && !jsonObj.get("backfill_start_time").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `backfill_start_time` to be a primitive type in the JSON string but got `%s`", jsonObj.get("backfill_start_time").toString()));
      }
      if ((jsonObj.get("compression") != null && !jsonObj.get("compression").isJsonNull()) && !jsonObj.get("compression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `compression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compression").toString()));
      }
      if ((jsonObj.get("container") != null && !jsonObj.get("container").isJsonNull()) && !jsonObj.get("container").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `container` to be a primitive type in the JSON string but got `%s`", jsonObj.get("container").toString()));
      }
      if ((jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) && !jsonObj.get("format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("format").toString()));
      }
      if ((jsonObj.get("partition_format") != null && !jsonObj.get("partition_format").isJsonNull()) && !jsonObj.get("partition_format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `partition_format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partition_format").toString()));
      }
      if ((jsonObj.get("prefix") != null && !jsonObj.get("prefix").isJsonNull()) && !jsonObj.get("prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("prefix").toString()));
      }
      if ((jsonObj.get("record_location") != null && !jsonObj.get("record_location").isJsonNull()) && !jsonObj.get("record_location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `record_location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("record_location").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AzureBlobStorageSettingsConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AzureBlobStorageSettingsConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AzureBlobStorageSettingsConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AzureBlobStorageSettingsConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<AzureBlobStorageSettingsConfig>() {
           @Override
           public void write(JsonWriter out, AzureBlobStorageSettingsConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AzureBlobStorageSettingsConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AzureBlobStorageSettingsConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AzureBlobStorageSettingsConfig
   * @throws IOException if the JSON string is invalid with respect to AzureBlobStorageSettingsConfig
   */
  public static AzureBlobStorageSettingsConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AzureBlobStorageSettingsConfig.class);
  }

  /**
   * Convert an instance of AzureBlobStorageSettingsConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

