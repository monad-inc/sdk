/*
 * Monad API
 * This is the monad API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Object storage settings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-06-30T16:15:25.634936480Z[Etc/UTC]", comments = "Generator version: 7.14.0")
public class ObjectStorageInputSettingsConfig {
  public static final String SERIALIZED_NAME_BUCKET = "bucket";
  @SerializedName(SERIALIZED_NAME_BUCKET)
  @javax.annotation.Nullable
  private String bucket;

  public static final String SERIALIZED_NAME_COMPRESSION = "compression";
  @SerializedName(SERIALIZED_NAME_COMPRESSION)
  @javax.annotation.Nullable
  private String compression;

  public static final String SERIALIZED_NAME_ENDPOINT = "endpoint";
  @SerializedName(SERIALIZED_NAME_ENDPOINT)
  @javax.annotation.Nullable
  private String endpoint;

  public static final String SERIALIZED_NAME_FORMAT = "format";
  @SerializedName(SERIALIZED_NAME_FORMAT)
  @javax.annotation.Nullable
  private String format;

  public static final String SERIALIZED_NAME_PARTITION_FORMAT = "partition_format";
  @SerializedName(SERIALIZED_NAME_PARTITION_FORMAT)
  @javax.annotation.Nullable
  private String partitionFormat;

  public static final String SERIALIZED_NAME_PREFIX = "prefix";
  @SerializedName(SERIALIZED_NAME_PREFIX)
  @javax.annotation.Nullable
  private String prefix;

  public static final String SERIALIZED_NAME_RECORD_LOCATION = "record_location";
  @SerializedName(SERIALIZED_NAME_RECORD_LOCATION)
  @javax.annotation.Nullable
  private String recordLocation;

  public static final String SERIALIZED_NAME_REGION = "region";
  @SerializedName(SERIALIZED_NAME_REGION)
  @javax.annotation.Nullable
  private String region;

  public static final String SERIALIZED_NAME_SKIP_SSL_VERIFICATION = "skip_ssl_verification";
  @SerializedName(SERIALIZED_NAME_SKIP_SSL_VERIFICATION)
  @javax.annotation.Nullable
  private Boolean skipSslVerification;

  public static final String SERIALIZED_NAME_USE_PATH_STYLE = "use_path_style";
  @SerializedName(SERIALIZED_NAME_USE_PATH_STYLE)
  @javax.annotation.Nullable
  private Boolean usePathStyle;

  public ObjectStorageInputSettingsConfig() {
  }

  public ObjectStorageInputSettingsConfig bucket(@javax.annotation.Nullable String bucket) {
    this.bucket = bucket;
    return this;
  }

  /**
   * Name of the storage bucket
   * @return bucket
   */
  @javax.annotation.Nullable
  public String getBucket() {
    return bucket;
  }

  public void setBucket(@javax.annotation.Nullable String bucket) {
    this.bucket = bucket;
  }


  public ObjectStorageInputSettingsConfig compression(@javax.annotation.Nullable String compression) {
    this.compression = compression;
    return this;
  }

  /**
   * Compression format of the objects
   * @return compression
   */
  @javax.annotation.Nullable
  public String getCompression() {
    return compression;
  }

  public void setCompression(@javax.annotation.Nullable String compression) {
    this.compression = compression;
  }


  public ObjectStorageInputSettingsConfig endpoint(@javax.annotation.Nullable String endpoint) {
    this.endpoint = endpoint;
    return this;
  }

  /**
   * Endpoint URL for the object storage service (e.g., https://minio.example.com, https://s3.amazonaws.com)
   * @return endpoint
   */
  @javax.annotation.Nullable
  public String getEndpoint() {
    return endpoint;
  }

  public void setEndpoint(@javax.annotation.Nullable String endpoint) {
    this.endpoint = endpoint;
  }


  public ObjectStorageInputSettingsConfig format(@javax.annotation.Nullable String format) {
    this.format = format;
    return this;
  }

  /**
   * File format of the objects
   * @return format
   */
  @javax.annotation.Nullable
  public String getFormat() {
    return format;
  }

  public void setFormat(@javax.annotation.Nullable String format) {
    this.format = format;
  }


  public ObjectStorageInputSettingsConfig partitionFormat(@javax.annotation.Nullable String partitionFormat) {
    this.partitionFormat = partitionFormat;
    return this;
  }

  /**
   * Specifies the partition format of your bucket. Select the option that matches how your data is currently organized. This ensures that the system can correctly navigate your bucket structure. Options include Hive-compatible format (&#39;year&#x3D;2024/month&#x3D;01/day&#x3D;01&#39;) commonly used in data lake setups, and simple date format (&#39;2024/01/01&#39;) for basic chronological organization.
   * @return partitionFormat
   */
  @javax.annotation.Nullable
  public String getPartitionFormat() {
    return partitionFormat;
  }

  public void setPartitionFormat(@javax.annotation.Nullable String partitionFormat) {
    this.partitionFormat = partitionFormat;
  }


  public ObjectStorageInputSettingsConfig prefix(@javax.annotation.Nullable String prefix) {
    this.prefix = prefix;
    return this;
  }

  /**
   * Prefix that leads to the start of the expected partition. For example: \&quot;/foobar/year&#x3D;2024/month&#x3D;01/day&#x3D;01/\&quot;. The prefix is &#x60;foobar&#x60;.
   * @return prefix
   */
  @javax.annotation.Nullable
  public String getPrefix() {
    return prefix;
  }

  public void setPrefix(@javax.annotation.Nullable String prefix) {
    this.prefix = prefix;
  }


  public ObjectStorageInputSettingsConfig recordLocation(@javax.annotation.Nullable String recordLocation) {
    this.recordLocation = recordLocation;
    return this;
  }

  /**
   * Location of the record in the JSON object. This can be ignored if the record is not in JSON format. If the records are not nested in the JSON, you can use &#39;@this&#39; to indicate that the file contains the record at the root or an array of records.
   * @return recordLocation
   */
  @javax.annotation.Nullable
  public String getRecordLocation() {
    return recordLocation;
  }

  public void setRecordLocation(@javax.annotation.Nullable String recordLocation) {
    this.recordLocation = recordLocation;
  }


  public ObjectStorageInputSettingsConfig region(@javax.annotation.Nullable String region) {
    this.region = region;
    return this;
  }

  /**
   * Optional region for the object storage service. This is often required for services like AWS S3.
   * @return region
   */
  @javax.annotation.Nullable
  public String getRegion() {
    return region;
  }

  public void setRegion(@javax.annotation.Nullable String region) {
    this.region = region;
  }


  public ObjectStorageInputSettingsConfig skipSslVerification(@javax.annotation.Nullable Boolean skipSslVerification) {
    this.skipSslVerification = skipSslVerification;
    return this;
  }

  /**
   * Skip SSL verification for self-signed certificates
   * @return skipSslVerification
   */
  @javax.annotation.Nullable
  public Boolean getSkipSslVerification() {
    return skipSslVerification;
  }

  public void setSkipSslVerification(@javax.annotation.Nullable Boolean skipSslVerification) {
    this.skipSslVerification = skipSslVerification;
  }


  public ObjectStorageInputSettingsConfig usePathStyle(@javax.annotation.Nullable Boolean usePathStyle) {
    this.usePathStyle = usePathStyle;
    return this;
  }

  /**
   * Whether to use path-style URLs (bucket.endpoint.com/object vs endpoint.com/bucket/object). Most S3-compatible services require this to be true.
   * @return usePathStyle
   */
  @javax.annotation.Nullable
  public Boolean getUsePathStyle() {
    return usePathStyle;
  }

  public void setUsePathStyle(@javax.annotation.Nullable Boolean usePathStyle) {
    this.usePathStyle = usePathStyle;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ObjectStorageInputSettingsConfig objectStorageInputSettingsConfig = (ObjectStorageInputSettingsConfig) o;
    return Objects.equals(this.bucket, objectStorageInputSettingsConfig.bucket) &&
        Objects.equals(this.compression, objectStorageInputSettingsConfig.compression) &&
        Objects.equals(this.endpoint, objectStorageInputSettingsConfig.endpoint) &&
        Objects.equals(this.format, objectStorageInputSettingsConfig.format) &&
        Objects.equals(this.partitionFormat, objectStorageInputSettingsConfig.partitionFormat) &&
        Objects.equals(this.prefix, objectStorageInputSettingsConfig.prefix) &&
        Objects.equals(this.recordLocation, objectStorageInputSettingsConfig.recordLocation) &&
        Objects.equals(this.region, objectStorageInputSettingsConfig.region) &&
        Objects.equals(this.skipSslVerification, objectStorageInputSettingsConfig.skipSslVerification) &&
        Objects.equals(this.usePathStyle, objectStorageInputSettingsConfig.usePathStyle);
  }

  @Override
  public int hashCode() {
    return Objects.hash(bucket, compression, endpoint, format, partitionFormat, prefix, recordLocation, region, skipSslVerification, usePathStyle);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ObjectStorageInputSettingsConfig {\n");
    sb.append("    bucket: ").append(toIndentedString(bucket)).append("\n");
    sb.append("    compression: ").append(toIndentedString(compression)).append("\n");
    sb.append("    endpoint: ").append(toIndentedString(endpoint)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    partitionFormat: ").append(toIndentedString(partitionFormat)).append("\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    recordLocation: ").append(toIndentedString(recordLocation)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    skipSslVerification: ").append(toIndentedString(skipSslVerification)).append("\n");
    sb.append("    usePathStyle: ").append(toIndentedString(usePathStyle)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("bucket", "compression", "endpoint", "format", "partition_format", "prefix", "record_location", "region", "skip_ssl_verification", "use_path_style"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ObjectStorageInputSettingsConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ObjectStorageInputSettingsConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ObjectStorageInputSettingsConfig is not found in the empty JSON string", ObjectStorageInputSettingsConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ObjectStorageInputSettingsConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ObjectStorageInputSettingsConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("bucket") != null && !jsonObj.get("bucket").isJsonNull()) && !jsonObj.get("bucket").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bucket` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bucket").toString()));
      }
      if ((jsonObj.get("compression") != null && !jsonObj.get("compression").isJsonNull()) && !jsonObj.get("compression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compression").toString()));
      }
      if ((jsonObj.get("endpoint") != null && !jsonObj.get("endpoint").isJsonNull()) && !jsonObj.get("endpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endpoint").toString()));
      }
      if ((jsonObj.get("format") != null && !jsonObj.get("format").isJsonNull()) && !jsonObj.get("format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("format").toString()));
      }
      if ((jsonObj.get("partition_format") != null && !jsonObj.get("partition_format").isJsonNull()) && !jsonObj.get("partition_format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partition_format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partition_format").toString()));
      }
      if ((jsonObj.get("prefix") != null && !jsonObj.get("prefix").isJsonNull()) && !jsonObj.get("prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("prefix").toString()));
      }
      if ((jsonObj.get("record_location") != null && !jsonObj.get("record_location").isJsonNull()) && !jsonObj.get("record_location").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `record_location` to be a primitive type in the JSON string but got `%s`", jsonObj.get("record_location").toString()));
      }
      if ((jsonObj.get("region") != null && !jsonObj.get("region").isJsonNull()) && !jsonObj.get("region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("region").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ObjectStorageInputSettingsConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ObjectStorageInputSettingsConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ObjectStorageInputSettingsConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ObjectStorageInputSettingsConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<ObjectStorageInputSettingsConfig>() {
           @Override
           public void write(JsonWriter out, ObjectStorageInputSettingsConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ObjectStorageInputSettingsConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ObjectStorageInputSettingsConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ObjectStorageInputSettingsConfig
   * @throws IOException if the JSON string is invalid with respect to ObjectStorageInputSettingsConfig
   */
  public static ObjectStorageInputSettingsConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ObjectStorageInputSettingsConfig.class);
  }

  /**
   * Convert an instance of ObjectStorageInputSettingsConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

