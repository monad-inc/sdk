/*
 * Monad API
 * This is the monad API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.BatchConfigBatchConfig;
import org.openapitools.client.model.FormatterFormatConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Object Storage Output Settings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-06-11T18:00:51.126379750Z[Etc/UTC]", comments = "Generator version: 7.13.0")
public class ObjectStorageSettingsConfig {
  public static final String SERIALIZED_NAME_BATCH_CONFIG = "batch_config";
  @SerializedName(SERIALIZED_NAME_BATCH_CONFIG)
  @javax.annotation.Nullable
  private BatchConfigBatchConfig batchConfig;

  public static final String SERIALIZED_NAME_BUCKET = "bucket";
  @SerializedName(SERIALIZED_NAME_BUCKET)
  @javax.annotation.Nullable
  private String bucket;

  public static final String SERIALIZED_NAME_COMPRESSION = "compression";
  @SerializedName(SERIALIZED_NAME_COMPRESSION)
  @javax.annotation.Nullable
  private String compression;

  public static final String SERIALIZED_NAME_ENDPOINT = "endpoint";
  @SerializedName(SERIALIZED_NAME_ENDPOINT)
  @javax.annotation.Nullable
  private String endpoint;

  public static final String SERIALIZED_NAME_FORMAT_CONFIG = "format_config";
  @SerializedName(SERIALIZED_NAME_FORMAT_CONFIG)
  @javax.annotation.Nullable
  private FormatterFormatConfig formatConfig;

  public static final String SERIALIZED_NAME_PARTITION_FORMAT = "partition_format";
  @SerializedName(SERIALIZED_NAME_PARTITION_FORMAT)
  @javax.annotation.Nullable
  private String partitionFormat;

  public static final String SERIALIZED_NAME_PREFIX = "prefix";
  @SerializedName(SERIALIZED_NAME_PREFIX)
  @javax.annotation.Nullable
  private String prefix;

  public static final String SERIALIZED_NAME_REGION = "region";
  @SerializedName(SERIALIZED_NAME_REGION)
  @javax.annotation.Nullable
  private String region;

  public static final String SERIALIZED_NAME_SKIP_SSL_VERIFICATION = "skip_ssl_verification";
  @SerializedName(SERIALIZED_NAME_SKIP_SSL_VERIFICATION)
  @javax.annotation.Nullable
  private Boolean skipSslVerification;

  public static final String SERIALIZED_NAME_USE_PATH_STYLE = "use_path_style";
  @SerializedName(SERIALIZED_NAME_USE_PATH_STYLE)
  @javax.annotation.Nullable
  private Boolean usePathStyle;

  public ObjectStorageSettingsConfig() {
  }

  public ObjectStorageSettingsConfig batchConfig(@javax.annotation.Nullable BatchConfigBatchConfig batchConfig) {
    this.batchConfig = batchConfig;
    return this;
  }

  /**
   * Get batchConfig
   * @return batchConfig
   */
  @javax.annotation.Nullable
  public BatchConfigBatchConfig getBatchConfig() {
    return batchConfig;
  }

  public void setBatchConfig(@javax.annotation.Nullable BatchConfigBatchConfig batchConfig) {
    this.batchConfig = batchConfig;
  }


  public ObjectStorageSettingsConfig bucket(@javax.annotation.Nullable String bucket) {
    this.bucket = bucket;
    return this;
  }

  /**
   * The name of the object storage bucket where data will be stored
   * @return bucket
   */
  @javax.annotation.Nullable
  public String getBucket() {
    return bucket;
  }

  public void setBucket(@javax.annotation.Nullable String bucket) {
    this.bucket = bucket;
  }


  public ObjectStorageSettingsConfig compression(@javax.annotation.Nullable String compression) {
    this.compression = compression;
    return this;
  }

  /**
   * The compression method to be applied to the data before storing
   * @return compression
   */
  @javax.annotation.Nullable
  public String getCompression() {
    return compression;
  }

  public void setCompression(@javax.annotation.Nullable String compression) {
    this.compression = compression;
  }


  public ObjectStorageSettingsConfig endpoint(@javax.annotation.Nullable String endpoint) {
    this.endpoint = endpoint;
    return this;
  }

  /**
   * The endpoint URL for the object storage service (e.g., https://fly.storage.tigris.dev, https://minio.example.com)
   * @return endpoint
   */
  @javax.annotation.Nullable
  public String getEndpoint() {
    return endpoint;
  }

  public void setEndpoint(@javax.annotation.Nullable String endpoint) {
    this.endpoint = endpoint;
  }


  public ObjectStorageSettingsConfig formatConfig(@javax.annotation.Nullable FormatterFormatConfig formatConfig) {
    this.formatConfig = formatConfig;
    return this;
  }

  /**
   * Get formatConfig
   * @return formatConfig
   */
  @javax.annotation.Nullable
  public FormatterFormatConfig getFormatConfig() {
    return formatConfig;
  }

  public void setFormatConfig(@javax.annotation.Nullable FormatterFormatConfig formatConfig) {
    this.formatConfig = formatConfig;
  }


  public ObjectStorageSettingsConfig partitionFormat(@javax.annotation.Nullable String partitionFormat) {
    this.partitionFormat = partitionFormat;
    return this;
  }

  /**
   * Specifies the format for organizing data into partitions within your bucket. This determines the directory structure and naming convention for stored objects, affecting data organization and query efficiency. Examples include Hive-style partitioning (e.g., &#39;year&#x3D;2024/month&#x3D;01/day&#x3D;01&#39;) and simple date-based formats (e.g., &#39;2024/01/01&#39;).
   * @return partitionFormat
   */
  @javax.annotation.Nullable
  public String getPartitionFormat() {
    return partitionFormat;
  }

  public void setPartitionFormat(@javax.annotation.Nullable String partitionFormat) {
    this.partitionFormat = partitionFormat;
  }


  public ObjectStorageSettingsConfig prefix(@javax.annotation.Nullable String prefix) {
    this.prefix = prefix;
    return this;
  }

  /**
   * An optional prefix for object keys to organize data within the bucket
   * @return prefix
   */
  @javax.annotation.Nullable
  public String getPrefix() {
    return prefix;
  }

  public void setPrefix(@javax.annotation.Nullable String prefix) {
    this.prefix = prefix;
  }


  public ObjectStorageSettingsConfig region(@javax.annotation.Nullable String region) {
    this.region = region;
    return this;
  }

  /**
   * The region for the object storage service (optional for some providers)
   * @return region
   */
  @javax.annotation.Nullable
  public String getRegion() {
    return region;
  }

  public void setRegion(@javax.annotation.Nullable String region) {
    this.region = region;
  }


  public ObjectStorageSettingsConfig skipSslVerification(@javax.annotation.Nullable Boolean skipSslVerification) {
    this.skipSslVerification = skipSslVerification;
    return this;
  }

  /**
   * Whether to skip SSL certificate verification (useful for self-signed certificates or development environments)
   * @return skipSslVerification
   */
  @javax.annotation.Nullable
  public Boolean getSkipSslVerification() {
    return skipSslVerification;
  }

  public void setSkipSslVerification(@javax.annotation.Nullable Boolean skipSslVerification) {
    this.skipSslVerification = skipSslVerification;
  }


  public ObjectStorageSettingsConfig usePathStyle(@javax.annotation.Nullable Boolean usePathStyle) {
    this.usePathStyle = usePathStyle;
    return this;
  }

  /**
   * Whether to use path-style URLs (bucket.endpoint.com/object vs endpoint.com/bucket/object). Most S3-compatible services require this to be true.
   * @return usePathStyle
   */
  @javax.annotation.Nullable
  public Boolean getUsePathStyle() {
    return usePathStyle;
  }

  public void setUsePathStyle(@javax.annotation.Nullable Boolean usePathStyle) {
    this.usePathStyle = usePathStyle;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ObjectStorageSettingsConfig objectStorageSettingsConfig = (ObjectStorageSettingsConfig) o;
    return Objects.equals(this.batchConfig, objectStorageSettingsConfig.batchConfig) &&
        Objects.equals(this.bucket, objectStorageSettingsConfig.bucket) &&
        Objects.equals(this.compression, objectStorageSettingsConfig.compression) &&
        Objects.equals(this.endpoint, objectStorageSettingsConfig.endpoint) &&
        Objects.equals(this.formatConfig, objectStorageSettingsConfig.formatConfig) &&
        Objects.equals(this.partitionFormat, objectStorageSettingsConfig.partitionFormat) &&
        Objects.equals(this.prefix, objectStorageSettingsConfig.prefix) &&
        Objects.equals(this.region, objectStorageSettingsConfig.region) &&
        Objects.equals(this.skipSslVerification, objectStorageSettingsConfig.skipSslVerification) &&
        Objects.equals(this.usePathStyle, objectStorageSettingsConfig.usePathStyle);
  }

  @Override
  public int hashCode() {
    return Objects.hash(batchConfig, bucket, compression, endpoint, formatConfig, partitionFormat, prefix, region, skipSslVerification, usePathStyle);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ObjectStorageSettingsConfig {\n");
    sb.append("    batchConfig: ").append(toIndentedString(batchConfig)).append("\n");
    sb.append("    bucket: ").append(toIndentedString(bucket)).append("\n");
    sb.append("    compression: ").append(toIndentedString(compression)).append("\n");
    sb.append("    endpoint: ").append(toIndentedString(endpoint)).append("\n");
    sb.append("    formatConfig: ").append(toIndentedString(formatConfig)).append("\n");
    sb.append("    partitionFormat: ").append(toIndentedString(partitionFormat)).append("\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    skipSslVerification: ").append(toIndentedString(skipSslVerification)).append("\n");
    sb.append("    usePathStyle: ").append(toIndentedString(usePathStyle)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("batch_config");
    openapiFields.add("bucket");
    openapiFields.add("compression");
    openapiFields.add("endpoint");
    openapiFields.add("format_config");
    openapiFields.add("partition_format");
    openapiFields.add("prefix");
    openapiFields.add("region");
    openapiFields.add("skip_ssl_verification");
    openapiFields.add("use_path_style");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ObjectStorageSettingsConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ObjectStorageSettingsConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ObjectStorageSettingsConfig is not found in the empty JSON string", ObjectStorageSettingsConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ObjectStorageSettingsConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ObjectStorageSettingsConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `batch_config`
      if (jsonObj.get("batch_config") != null && !jsonObj.get("batch_config").isJsonNull()) {
        BatchConfigBatchConfig.validateJsonElement(jsonObj.get("batch_config"));
      }
      if ((jsonObj.get("bucket") != null && !jsonObj.get("bucket").isJsonNull()) && !jsonObj.get("bucket").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bucket` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bucket").toString()));
      }
      if ((jsonObj.get("compression") != null && !jsonObj.get("compression").isJsonNull()) && !jsonObj.get("compression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compression").toString()));
      }
      if ((jsonObj.get("endpoint") != null && !jsonObj.get("endpoint").isJsonNull()) && !jsonObj.get("endpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endpoint").toString()));
      }
      // validate the optional field `format_config`
      if (jsonObj.get("format_config") != null && !jsonObj.get("format_config").isJsonNull()) {
        FormatterFormatConfig.validateJsonElement(jsonObj.get("format_config"));
      }
      if ((jsonObj.get("partition_format") != null && !jsonObj.get("partition_format").isJsonNull()) && !jsonObj.get("partition_format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partition_format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partition_format").toString()));
      }
      if ((jsonObj.get("prefix") != null && !jsonObj.get("prefix").isJsonNull()) && !jsonObj.get("prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("prefix").toString()));
      }
      if ((jsonObj.get("region") != null && !jsonObj.get("region").isJsonNull()) && !jsonObj.get("region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("region").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ObjectStorageSettingsConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ObjectStorageSettingsConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ObjectStorageSettingsConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ObjectStorageSettingsConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<ObjectStorageSettingsConfig>() {
           @Override
           public void write(JsonWriter out, ObjectStorageSettingsConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ObjectStorageSettingsConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ObjectStorageSettingsConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ObjectStorageSettingsConfig
   * @throws IOException if the JSON string is invalid with respect to ObjectStorageSettingsConfig
   */
  public static ObjectStorageSettingsConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ObjectStorageSettingsConfig.class);
  }

  /**
   * Convert an instance of ObjectStorageSettingsConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

