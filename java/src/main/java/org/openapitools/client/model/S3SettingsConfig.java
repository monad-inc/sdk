/*
 * Monad Swagger API
 * This is the monad API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import org.openapitools.client.model.BatchConfigBatchConfig;
import org.openapitools.client.model.FormatterFormatConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * S3 Output Settings
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-18T03:49:24.110298803Z[Etc/UTC]", comments = "Generator version: 7.12.0")
public class S3SettingsConfig {
  public static final String SERIALIZED_NAME_BATCH_CONFIG = "batch_config";
  @SerializedName(SERIALIZED_NAME_BATCH_CONFIG)
  @javax.annotation.Nullable
  private BatchConfigBatchConfig batchConfig;

  public static final String SERIALIZED_NAME_BUCKET = "bucket";
  @SerializedName(SERIALIZED_NAME_BUCKET)
  @javax.annotation.Nullable
  private String bucket;

  public static final String SERIALIZED_NAME_COMPRESSION = "compression";
  @SerializedName(SERIALIZED_NAME_COMPRESSION)
  @javax.annotation.Nullable
  private String compression;

  public static final String SERIALIZED_NAME_FORMAT_CONFIG = "format_config";
  @SerializedName(SERIALIZED_NAME_FORMAT_CONFIG)
  @javax.annotation.Nullable
  private FormatterFormatConfig formatConfig;

  public static final String SERIALIZED_NAME_PARTITION_FORMAT = "partition_format";
  @SerializedName(SERIALIZED_NAME_PARTITION_FORMAT)
  @javax.annotation.Nullable
  private String partitionFormat;

  public static final String SERIALIZED_NAME_PREFIX = "prefix";
  @SerializedName(SERIALIZED_NAME_PREFIX)
  @javax.annotation.Nullable
  private String prefix;

  public static final String SERIALIZED_NAME_REGION = "region";
  @SerializedName(SERIALIZED_NAME_REGION)
  @javax.annotation.Nullable
  private String region;

  public static final String SERIALIZED_NAME_ROLE_ARN = "role_arn";
  @SerializedName(SERIALIZED_NAME_ROLE_ARN)
  @javax.annotation.Nullable
  private String roleArn;

  public S3SettingsConfig() {
  }

  public S3SettingsConfig batchConfig(@javax.annotation.Nullable BatchConfigBatchConfig batchConfig) {
    this.batchConfig = batchConfig;
    return this;
  }

  /**
   * Get batchConfig
   * @return batchConfig
   */
  @javax.annotation.Nullable
  public BatchConfigBatchConfig getBatchConfig() {
    return batchConfig;
  }

  public void setBatchConfig(@javax.annotation.Nullable BatchConfigBatchConfig batchConfig) {
    this.batchConfig = batchConfig;
  }


  public S3SettingsConfig bucket(@javax.annotation.Nullable String bucket) {
    this.bucket = bucket;
    return this;
  }

  /**
   * The name of the S3 bucket where data will be stored
   * @return bucket
   */
  @javax.annotation.Nullable
  public String getBucket() {
    return bucket;
  }

  public void setBucket(@javax.annotation.Nullable String bucket) {
    this.bucket = bucket;
  }


  public S3SettingsConfig compression(@javax.annotation.Nullable String compression) {
    this.compression = compression;
    return this;
  }

  /**
   * The compression method to be applied to the data before storing in S3
   * @return compression
   */
  @javax.annotation.Nullable
  public String getCompression() {
    return compression;
  }

  public void setCompression(@javax.annotation.Nullable String compression) {
    this.compression = compression;
  }


  public S3SettingsConfig formatConfig(@javax.annotation.Nullable FormatterFormatConfig formatConfig) {
    this.formatConfig = formatConfig;
    return this;
  }

  /**
   * Get formatConfig
   * @return formatConfig
   */
  @javax.annotation.Nullable
  public FormatterFormatConfig getFormatConfig() {
    return formatConfig;
  }

  public void setFormatConfig(@javax.annotation.Nullable FormatterFormatConfig formatConfig) {
    this.formatConfig = formatConfig;
  }


  public S3SettingsConfig partitionFormat(@javax.annotation.Nullable String partitionFormat) {
    this.partitionFormat = partitionFormat;
    return this;
  }

  /**
   * Specifies the format for organizing data into partitions within your S3 bucket. This determines the directory structure and naming convention for stored objects, affecting data organization and query efficiency. Examples include Hive-style partitioning (e.g., &#39;year&#x3D;2024/month&#x3D;01/day&#x3D;01&#39;) and simple date-based formats (e.g., &#39;2024/01/01&#39;).
   * @return partitionFormat
   */
  @javax.annotation.Nullable
  public String getPartitionFormat() {
    return partitionFormat;
  }

  public void setPartitionFormat(@javax.annotation.Nullable String partitionFormat) {
    this.partitionFormat = partitionFormat;
  }


  public S3SettingsConfig prefix(@javax.annotation.Nullable String prefix) {
    this.prefix = prefix;
    return this;
  }

  /**
   * An optional prefix for S3 object keys to organize data within the bucket
   * @return prefix
   */
  @javax.annotation.Nullable
  public String getPrefix() {
    return prefix;
  }

  public void setPrefix(@javax.annotation.Nullable String prefix) {
    this.prefix = prefix;
  }


  public S3SettingsConfig region(@javax.annotation.Nullable String region) {
    this.region = region;
    return this;
  }

  /**
   * The AWS region where the S3 bucket is located
   * @return region
   */
  @javax.annotation.Nullable
  public String getRegion() {
    return region;
  }

  public void setRegion(@javax.annotation.Nullable String region) {
    this.region = region;
  }


  public S3SettingsConfig roleArn(@javax.annotation.Nullable String roleArn) {
    this.roleArn = roleArn;
    return this;
  }

  /**
   * The Amazon Resource Name (ARN) of the IAM role to assume which grants access to the S3 bucket
   * @return roleArn
   */
  @javax.annotation.Nullable
  public String getRoleArn() {
    return roleArn;
  }

  public void setRoleArn(@javax.annotation.Nullable String roleArn) {
    this.roleArn = roleArn;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    S3SettingsConfig s3SettingsConfig = (S3SettingsConfig) o;
    return Objects.equals(this.batchConfig, s3SettingsConfig.batchConfig) &&
        Objects.equals(this.bucket, s3SettingsConfig.bucket) &&
        Objects.equals(this.compression, s3SettingsConfig.compression) &&
        Objects.equals(this.formatConfig, s3SettingsConfig.formatConfig) &&
        Objects.equals(this.partitionFormat, s3SettingsConfig.partitionFormat) &&
        Objects.equals(this.prefix, s3SettingsConfig.prefix) &&
        Objects.equals(this.region, s3SettingsConfig.region) &&
        Objects.equals(this.roleArn, s3SettingsConfig.roleArn);
  }

  @Override
  public int hashCode() {
    return Objects.hash(batchConfig, bucket, compression, formatConfig, partitionFormat, prefix, region, roleArn);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class S3SettingsConfig {\n");
    sb.append("    batchConfig: ").append(toIndentedString(batchConfig)).append("\n");
    sb.append("    bucket: ").append(toIndentedString(bucket)).append("\n");
    sb.append("    compression: ").append(toIndentedString(compression)).append("\n");
    sb.append("    formatConfig: ").append(toIndentedString(formatConfig)).append("\n");
    sb.append("    partitionFormat: ").append(toIndentedString(partitionFormat)).append("\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    region: ").append(toIndentedString(region)).append("\n");
    sb.append("    roleArn: ").append(toIndentedString(roleArn)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("batch_config");
    openapiFields.add("bucket");
    openapiFields.add("compression");
    openapiFields.add("format_config");
    openapiFields.add("partition_format");
    openapiFields.add("prefix");
    openapiFields.add("region");
    openapiFields.add("role_arn");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to S3SettingsConfig
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!S3SettingsConfig.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in S3SettingsConfig is not found in the empty JSON string", S3SettingsConfig.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!S3SettingsConfig.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `S3SettingsConfig` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `batch_config`
      if (jsonObj.get("batch_config") != null && !jsonObj.get("batch_config").isJsonNull()) {
        BatchConfigBatchConfig.validateJsonElement(jsonObj.get("batch_config"));
      }
      if ((jsonObj.get("bucket") != null && !jsonObj.get("bucket").isJsonNull()) && !jsonObj.get("bucket").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bucket` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bucket").toString()));
      }
      if ((jsonObj.get("compression") != null && !jsonObj.get("compression").isJsonNull()) && !jsonObj.get("compression").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compression` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compression").toString()));
      }
      // validate the optional field `format_config`
      if (jsonObj.get("format_config") != null && !jsonObj.get("format_config").isJsonNull()) {
        FormatterFormatConfig.validateJsonElement(jsonObj.get("format_config"));
      }
      if ((jsonObj.get("partition_format") != null && !jsonObj.get("partition_format").isJsonNull()) && !jsonObj.get("partition_format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `partition_format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("partition_format").toString()));
      }
      if ((jsonObj.get("prefix") != null && !jsonObj.get("prefix").isJsonNull()) && !jsonObj.get("prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("prefix").toString()));
      }
      if ((jsonObj.get("region") != null && !jsonObj.get("region").isJsonNull()) && !jsonObj.get("region").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `region` to be a primitive type in the JSON string but got `%s`", jsonObj.get("region").toString()));
      }
      if ((jsonObj.get("role_arn") != null && !jsonObj.get("role_arn").isJsonNull()) && !jsonObj.get("role_arn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `role_arn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("role_arn").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!S3SettingsConfig.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'S3SettingsConfig' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<S3SettingsConfig> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(S3SettingsConfig.class));

       return (TypeAdapter<T>) new TypeAdapter<S3SettingsConfig>() {
           @Override
           public void write(JsonWriter out, S3SettingsConfig value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public S3SettingsConfig read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of S3SettingsConfig given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of S3SettingsConfig
   * @throws IOException if the JSON string is invalid with respect to S3SettingsConfig
   */
  public static S3SettingsConfig fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, S3SettingsConfig.class);
  }

  /**
   * Convert an instance of S3SettingsConfig to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

