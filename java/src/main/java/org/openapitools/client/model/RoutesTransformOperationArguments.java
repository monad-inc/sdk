/*
 * Monad API
 * This is the monad API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Map;
import org.openapitools.client.model.AddAdd;
import org.openapitools.client.model.CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue;
import org.openapitools.client.model.DropKeyDropKey;
import org.openapitools.client.model.DropKeyWhereValueEqDropKeyWhereValueEq;
import org.openapitools.client.model.DropRecordWhereValueEqDropRecordWhereValueEq;
import org.openapitools.client.model.DuplicateKeyValueToKeyDuplicateKeyValueToKey;
import org.openapitools.client.model.FlattenFlatten;
import org.openapitools.client.model.FlattenallFlattenAll;
import org.openapitools.client.model.JqJQ;
import org.openapitools.client.model.MathMultiplyWithValueMathMultiplyWithValue;
import org.openapitools.client.model.MutateTypeMutateType;
import org.openapitools.client.model.MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq;
import org.openapitools.client.model.MutateValueWhereKeyEqMutateValueWhereKeyEq;
import org.openapitools.client.model.RenameKeyRenameKey;
import org.openapitools.client.model.RenameKeyWhereValueEqRenameKeyWhereValueEq;
import org.openapitools.client.model.UtcTimestampTimestamp;
import org.openapitools.jackson.nullable.JsonNullable;



import java.io.IOException;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.JsonPrimitive;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import com.google.gson.JsonParseException;

import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-16T18:56:56.864376713Z[Etc/UTC]", comments = "Generator version: 7.13.0")
public class RoutesTransformOperationArguments extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(RoutesTransformOperationArguments.class.getName());

    public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
        @SuppressWarnings("unchecked")
        @Override
        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
            if (!RoutesTransformOperationArguments.class.isAssignableFrom(type.getRawType())) {
                return null; // this class only serializes 'RoutesTransformOperationArguments' and its subtypes
            }
            final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
            final TypeAdapter<AddAdd> adapterAddAdd = gson.getDelegateAdapter(this, TypeToken.get(AddAdd.class));
            final TypeAdapter<CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue> adapterCreateKeyValueIfKeyValueCreateKeyValueIfKeyValue = gson.getDelegateAdapter(this, TypeToken.get(CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue.class));
            final TypeAdapter<DropKeyDropKey> adapterDropKeyDropKey = gson.getDelegateAdapter(this, TypeToken.get(DropKeyDropKey.class));
            final TypeAdapter<DropKeyWhereValueEqDropKeyWhereValueEq> adapterDropKeyWhereValueEqDropKeyWhereValueEq = gson.getDelegateAdapter(this, TypeToken.get(DropKeyWhereValueEqDropKeyWhereValueEq.class));
            final TypeAdapter<DropRecordWhereValueEqDropRecordWhereValueEq> adapterDropRecordWhereValueEqDropRecordWhereValueEq = gson.getDelegateAdapter(this, TypeToken.get(DropRecordWhereValueEqDropRecordWhereValueEq.class));
            final TypeAdapter<DuplicateKeyValueToKeyDuplicateKeyValueToKey> adapterDuplicateKeyValueToKeyDuplicateKeyValueToKey = gson.getDelegateAdapter(this, TypeToken.get(DuplicateKeyValueToKeyDuplicateKeyValueToKey.class));
            final TypeAdapter<FlattenFlatten> adapterFlattenFlatten = gson.getDelegateAdapter(this, TypeToken.get(FlattenFlatten.class));
            final TypeAdapter<FlattenallFlattenAll> adapterFlattenallFlattenAll = gson.getDelegateAdapter(this, TypeToken.get(FlattenallFlattenAll.class));
            final TypeAdapter<JqJQ> adapterJqJQ = gson.getDelegateAdapter(this, TypeToken.get(JqJQ.class));
            final TypeAdapter<MathMultiplyWithValueMathMultiplyWithValue> adapterMathMultiplyWithValueMathMultiplyWithValue = gson.getDelegateAdapter(this, TypeToken.get(MathMultiplyWithValueMathMultiplyWithValue.class));
            final Type typeInstanceMapStringObject = new TypeToken<Map<String, Object>>(){}.getType();
            final TypeAdapter<Map<String, Object>> adapterMapStringObject = (TypeAdapter<Map<String, Object>>) gson.getDelegateAdapter(this, TypeToken.get(typeInstanceMapStringObject));
            final TypeAdapter<MutateTypeMutateType> adapterMutateTypeMutateType = gson.getDelegateAdapter(this, TypeToken.get(MutateTypeMutateType.class));
            final TypeAdapter<MutateValueWhereKeyEqMutateValueWhereKeyEq> adapterMutateValueWhereKeyEqMutateValueWhereKeyEq = gson.getDelegateAdapter(this, TypeToken.get(MutateValueWhereKeyEqMutateValueWhereKeyEq.class));
            final TypeAdapter<MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq> adapterMutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq = gson.getDelegateAdapter(this, TypeToken.get(MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq.class));
            final TypeAdapter<RenameKeyRenameKey> adapterRenameKeyRenameKey = gson.getDelegateAdapter(this, TypeToken.get(RenameKeyRenameKey.class));
            final TypeAdapter<RenameKeyWhereValueEqRenameKeyWhereValueEq> adapterRenameKeyWhereValueEqRenameKeyWhereValueEq = gson.getDelegateAdapter(this, TypeToken.get(RenameKeyWhereValueEqRenameKeyWhereValueEq.class));
            final TypeAdapter<UtcTimestampTimestamp> adapterUtcTimestampTimestamp = gson.getDelegateAdapter(this, TypeToken.get(UtcTimestampTimestamp.class));

            return (TypeAdapter<T>) new TypeAdapter<RoutesTransformOperationArguments>() {
                @Override
                public void write(JsonWriter out, RoutesTransformOperationArguments value) throws IOException {
                    if (value == null || value.getActualInstance() == null) {
                        elementAdapter.write(out, null);
                        return;
                    }

                    // check if the actual instance is of the type `AddAdd`
                    if (value.getActualInstance() instanceof AddAdd) {
                        JsonElement element = adapterAddAdd.toJsonTree((AddAdd)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue`
                    if (value.getActualInstance() instanceof CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue) {
                        JsonElement element = adapterCreateKeyValueIfKeyValueCreateKeyValueIfKeyValue.toJsonTree((CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DropKeyDropKey`
                    if (value.getActualInstance() instanceof DropKeyDropKey) {
                        JsonElement element = adapterDropKeyDropKey.toJsonTree((DropKeyDropKey)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DropKeyWhereValueEqDropKeyWhereValueEq`
                    if (value.getActualInstance() instanceof DropKeyWhereValueEqDropKeyWhereValueEq) {
                        JsonElement element = adapterDropKeyWhereValueEqDropKeyWhereValueEq.toJsonTree((DropKeyWhereValueEqDropKeyWhereValueEq)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DropRecordWhereValueEqDropRecordWhereValueEq`
                    if (value.getActualInstance() instanceof DropRecordWhereValueEqDropRecordWhereValueEq) {
                        JsonElement element = adapterDropRecordWhereValueEqDropRecordWhereValueEq.toJsonTree((DropRecordWhereValueEqDropRecordWhereValueEq)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `DuplicateKeyValueToKeyDuplicateKeyValueToKey`
                    if (value.getActualInstance() instanceof DuplicateKeyValueToKeyDuplicateKeyValueToKey) {
                        JsonElement element = adapterDuplicateKeyValueToKeyDuplicateKeyValueToKey.toJsonTree((DuplicateKeyValueToKeyDuplicateKeyValueToKey)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `FlattenFlatten`
                    if (value.getActualInstance() instanceof FlattenFlatten) {
                        JsonElement element = adapterFlattenFlatten.toJsonTree((FlattenFlatten)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `FlattenallFlattenAll`
                    if (value.getActualInstance() instanceof FlattenallFlattenAll) {
                        JsonElement element = adapterFlattenallFlattenAll.toJsonTree((FlattenallFlattenAll)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `JqJQ`
                    if (value.getActualInstance() instanceof JqJQ) {
                        JsonElement element = adapterJqJQ.toJsonTree((JqJQ)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `MathMultiplyWithValueMathMultiplyWithValue`
                    if (value.getActualInstance() instanceof MathMultiplyWithValueMathMultiplyWithValue) {
                        JsonElement element = adapterMathMultiplyWithValueMathMultiplyWithValue.toJsonTree((MathMultiplyWithValueMathMultiplyWithValue)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `Map<String, Object>`
                    if (value.getActualInstance() instanceof Map<?, ?>) {
                        JsonObject object = adapterMapStringObject.toJsonTree((Map<String, Object>)value.getActualInstance()).getAsJsonObject();
                        elementAdapter.write(out, object);
                        return;
                    }
                    // check if the actual instance is of the type `MutateTypeMutateType`
                    if (value.getActualInstance() instanceof MutateTypeMutateType) {
                        JsonElement element = adapterMutateTypeMutateType.toJsonTree((MutateTypeMutateType)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `MutateValueWhereKeyEqMutateValueWhereKeyEq`
                    if (value.getActualInstance() instanceof MutateValueWhereKeyEqMutateValueWhereKeyEq) {
                        JsonElement element = adapterMutateValueWhereKeyEqMutateValueWhereKeyEq.toJsonTree((MutateValueWhereKeyEqMutateValueWhereKeyEq)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq`
                    if (value.getActualInstance() instanceof MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq) {
                        JsonElement element = adapterMutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq.toJsonTree((MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `RenameKeyRenameKey`
                    if (value.getActualInstance() instanceof RenameKeyRenameKey) {
                        JsonElement element = adapterRenameKeyRenameKey.toJsonTree((RenameKeyRenameKey)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `RenameKeyWhereValueEqRenameKeyWhereValueEq`
                    if (value.getActualInstance() instanceof RenameKeyWhereValueEqRenameKeyWhereValueEq) {
                        JsonElement element = adapterRenameKeyWhereValueEqRenameKeyWhereValueEq.toJsonTree((RenameKeyWhereValueEqRenameKeyWhereValueEq)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    // check if the actual instance is of the type `UtcTimestampTimestamp`
                    if (value.getActualInstance() instanceof UtcTimestampTimestamp) {
                        JsonElement element = adapterUtcTimestampTimestamp.toJsonTree((UtcTimestampTimestamp)value.getActualInstance());
                        elementAdapter.write(out, element);
                        return;
                    }
                    throw new IOException("Failed to serialize as the type doesn't match oneOf schemas: AddAdd, CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue, DropKeyDropKey, DropKeyWhereValueEqDropKeyWhereValueEq, DropRecordWhereValueEqDropRecordWhereValueEq, DuplicateKeyValueToKeyDuplicateKeyValueToKey, FlattenFlatten, FlattenallFlattenAll, JqJQ, Map<String, Object>, MathMultiplyWithValueMathMultiplyWithValue, MutateTypeMutateType, MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq, MutateValueWhereKeyEqMutateValueWhereKeyEq, RenameKeyRenameKey, RenameKeyWhereValueEqRenameKeyWhereValueEq, UtcTimestampTimestamp");
                }

                @Override
                public RoutesTransformOperationArguments read(JsonReader in) throws IOException {
                    Object deserialized = null;
                    JsonElement jsonElement = elementAdapter.read(in);

                    int match = 0;
                    ArrayList<String> errorMessages = new ArrayList<>();
                    TypeAdapter actualAdapter = elementAdapter;

                    // deserialize AddAdd
                    try {
                        // validate the JSON object to see if any exception is thrown
                        AddAdd.validateJsonElement(jsonElement);
                        actualAdapter = adapterAddAdd;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'AddAdd'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for AddAdd failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'AddAdd'", e);
                    }
                    // deserialize CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue
                    try {
                        // validate the JSON object to see if any exception is thrown
                        CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue.validateJsonElement(jsonElement);
                        actualAdapter = adapterCreateKeyValueIfKeyValueCreateKeyValueIfKeyValue;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue'", e);
                    }
                    // deserialize DropKeyDropKey
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DropKeyDropKey.validateJsonElement(jsonElement);
                        actualAdapter = adapterDropKeyDropKey;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DropKeyDropKey'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DropKeyDropKey failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DropKeyDropKey'", e);
                    }
                    // deserialize DropKeyWhereValueEqDropKeyWhereValueEq
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DropKeyWhereValueEqDropKeyWhereValueEq.validateJsonElement(jsonElement);
                        actualAdapter = adapterDropKeyWhereValueEqDropKeyWhereValueEq;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DropKeyWhereValueEqDropKeyWhereValueEq'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DropKeyWhereValueEqDropKeyWhereValueEq failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DropKeyWhereValueEqDropKeyWhereValueEq'", e);
                    }
                    // deserialize DropRecordWhereValueEqDropRecordWhereValueEq
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DropRecordWhereValueEqDropRecordWhereValueEq.validateJsonElement(jsonElement);
                        actualAdapter = adapterDropRecordWhereValueEqDropRecordWhereValueEq;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DropRecordWhereValueEqDropRecordWhereValueEq'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DropRecordWhereValueEqDropRecordWhereValueEq failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DropRecordWhereValueEqDropRecordWhereValueEq'", e);
                    }
                    // deserialize DuplicateKeyValueToKeyDuplicateKeyValueToKey
                    try {
                        // validate the JSON object to see if any exception is thrown
                        DuplicateKeyValueToKeyDuplicateKeyValueToKey.validateJsonElement(jsonElement);
                        actualAdapter = adapterDuplicateKeyValueToKeyDuplicateKeyValueToKey;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'DuplicateKeyValueToKeyDuplicateKeyValueToKey'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for DuplicateKeyValueToKeyDuplicateKeyValueToKey failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'DuplicateKeyValueToKeyDuplicateKeyValueToKey'", e);
                    }
                    // deserialize FlattenFlatten
                    try {
                        // validate the JSON object to see if any exception is thrown
                        FlattenFlatten.validateJsonElement(jsonElement);
                        actualAdapter = adapterFlattenFlatten;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'FlattenFlatten'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for FlattenFlatten failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'FlattenFlatten'", e);
                    }
                    // deserialize FlattenallFlattenAll
                    try {
                        // validate the JSON object to see if any exception is thrown
                        FlattenallFlattenAll.validateJsonElement(jsonElement);
                        actualAdapter = adapterFlattenallFlattenAll;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'FlattenallFlattenAll'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for FlattenallFlattenAll failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'FlattenallFlattenAll'", e);
                    }
                    // deserialize JqJQ
                    try {
                        // validate the JSON object to see if any exception is thrown
                        JqJQ.validateJsonElement(jsonElement);
                        actualAdapter = adapterJqJQ;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'JqJQ'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for JqJQ failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'JqJQ'", e);
                    }
                    // deserialize MathMultiplyWithValueMathMultiplyWithValue
                    try {
                        // validate the JSON object to see if any exception is thrown
                        MathMultiplyWithValueMathMultiplyWithValue.validateJsonElement(jsonElement);
                        actualAdapter = adapterMathMultiplyWithValueMathMultiplyWithValue;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'MathMultiplyWithValueMathMultiplyWithValue'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for MathMultiplyWithValueMathMultiplyWithValue failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'MathMultiplyWithValueMathMultiplyWithValue'", e);
                    }
                    // deserialize Map<String, Object>
                    try {
                        // validate the JSON object to see if any exception is thrown
                        if (!jsonElement.isJsonObject()) {
                            throw new IllegalArgumentException(String.format("Expected json element to be a object type in the JSON string but got `%s`", jsonElement.toString()));
                        }

                        actualAdapter = adapterMapStringObject;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'Map<String, Object>'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for Map<String, Object> failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'Map<String, Object>'", e);
                    }
                    // deserialize MutateTypeMutateType
                    try {
                        // validate the JSON object to see if any exception is thrown
                        MutateTypeMutateType.validateJsonElement(jsonElement);
                        actualAdapter = adapterMutateTypeMutateType;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'MutateTypeMutateType'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for MutateTypeMutateType failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'MutateTypeMutateType'", e);
                    }
                    // deserialize MutateValueWhereKeyEqMutateValueWhereKeyEq
                    try {
                        // validate the JSON object to see if any exception is thrown
                        MutateValueWhereKeyEqMutateValueWhereKeyEq.validateJsonElement(jsonElement);
                        actualAdapter = adapterMutateValueWhereKeyEqMutateValueWhereKeyEq;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'MutateValueWhereKeyEqMutateValueWhereKeyEq'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for MutateValueWhereKeyEqMutateValueWhereKeyEq failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'MutateValueWhereKeyEqMutateValueWhereKeyEq'", e);
                    }
                    // deserialize MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq
                    try {
                        // validate the JSON object to see if any exception is thrown
                        MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq.validateJsonElement(jsonElement);
                        actualAdapter = adapterMutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq'", e);
                    }
                    // deserialize RenameKeyRenameKey
                    try {
                        // validate the JSON object to see if any exception is thrown
                        RenameKeyRenameKey.validateJsonElement(jsonElement);
                        actualAdapter = adapterRenameKeyRenameKey;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'RenameKeyRenameKey'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for RenameKeyRenameKey failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'RenameKeyRenameKey'", e);
                    }
                    // deserialize RenameKeyWhereValueEqRenameKeyWhereValueEq
                    try {
                        // validate the JSON object to see if any exception is thrown
                        RenameKeyWhereValueEqRenameKeyWhereValueEq.validateJsonElement(jsonElement);
                        actualAdapter = adapterRenameKeyWhereValueEqRenameKeyWhereValueEq;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'RenameKeyWhereValueEqRenameKeyWhereValueEq'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for RenameKeyWhereValueEqRenameKeyWhereValueEq failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'RenameKeyWhereValueEqRenameKeyWhereValueEq'", e);
                    }
                    // deserialize UtcTimestampTimestamp
                    try {
                        // validate the JSON object to see if any exception is thrown
                        UtcTimestampTimestamp.validateJsonElement(jsonElement);
                        actualAdapter = adapterUtcTimestampTimestamp;
                        match++;
                        log.log(Level.FINER, "Input data matches schema 'UtcTimestampTimestamp'");
                    } catch (Exception e) {
                        // deserialization failed, continue
                        errorMessages.add(String.format("Deserialization for UtcTimestampTimestamp failed with `%s`.", e.getMessage()));
                        log.log(Level.FINER, "Input data does not match schema 'UtcTimestampTimestamp'", e);
                    }

                    if (match == 1) {
                        RoutesTransformOperationArguments ret = new RoutesTransformOperationArguments();
                        ret.setActualInstance(actualAdapter.fromJsonTree(jsonElement));
                        return ret;
                    }

                    throw new IOException(String.format("Failed deserialization for RoutesTransformOperationArguments: %d classes match result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", match, errorMessages, jsonElement.toString()));
                }
            }.nullSafe();
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public RoutesTransformOperationArguments() {
        super("oneOf", Boolean.FALSE);
    }

    public RoutesTransformOperationArguments(Object o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AddAdd", AddAdd.class);
        schemas.put("CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue", CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue.class);
        schemas.put("DropKeyDropKey", DropKeyDropKey.class);
        schemas.put("DropKeyWhereValueEqDropKeyWhereValueEq", DropKeyWhereValueEqDropKeyWhereValueEq.class);
        schemas.put("DropRecordWhereValueEqDropRecordWhereValueEq", DropRecordWhereValueEqDropRecordWhereValueEq.class);
        schemas.put("DuplicateKeyValueToKeyDuplicateKeyValueToKey", DuplicateKeyValueToKeyDuplicateKeyValueToKey.class);
        schemas.put("FlattenFlatten", FlattenFlatten.class);
        schemas.put("FlattenallFlattenAll", FlattenallFlattenAll.class);
        schemas.put("JqJQ", JqJQ.class);
        schemas.put("MathMultiplyWithValueMathMultiplyWithValue", MathMultiplyWithValueMathMultiplyWithValue.class);
        schemas.put("Map<String, Object>", Map.class);
        schemas.put("MutateTypeMutateType", MutateTypeMutateType.class);
        schemas.put("MutateValueWhereKeyEqMutateValueWhereKeyEq", MutateValueWhereKeyEqMutateValueWhereKeyEq.class);
        schemas.put("MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq", MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq.class);
        schemas.put("RenameKeyRenameKey", RenameKeyRenameKey.class);
        schemas.put("RenameKeyWhereValueEqRenameKeyWhereValueEq", RenameKeyWhereValueEqRenameKeyWhereValueEq.class);
        schemas.put("UtcTimestampTimestamp", UtcTimestampTimestamp.class);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return RoutesTransformOperationArguments.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * AddAdd, CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue, DropKeyDropKey, DropKeyWhereValueEqDropKeyWhereValueEq, DropRecordWhereValueEqDropRecordWhereValueEq, DuplicateKeyValueToKeyDuplicateKeyValueToKey, FlattenFlatten, FlattenallFlattenAll, JqJQ, Map<String, Object>, MathMultiplyWithValueMathMultiplyWithValue, MutateTypeMutateType, MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq, MutateValueWhereKeyEqMutateValueWhereKeyEq, RenameKeyRenameKey, RenameKeyWhereValueEqRenameKeyWhereValueEq, UtcTimestampTimestamp
     *
     * It could be an instance of the 'oneOf' schemas.
     */
    @Override
    public void setActualInstance(Object instance) {
        if (instance instanceof AddAdd) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DropKeyDropKey) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DropKeyWhereValueEqDropKeyWhereValueEq) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DropRecordWhereValueEqDropRecordWhereValueEq) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof DuplicateKeyValueToKeyDuplicateKeyValueToKey) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof FlattenFlatten) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof FlattenallFlattenAll) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof JqJQ) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof MathMultiplyWithValueMathMultiplyWithValue) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof Map<?, ?>) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof MutateTypeMutateType) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof MutateValueWhereKeyEqMutateValueWhereKeyEq) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof RenameKeyRenameKey) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof RenameKeyWhereValueEqRenameKeyWhereValueEq) {
            super.setActualInstance(instance);
            return;
        }

        if (instance instanceof UtcTimestampTimestamp) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AddAdd, CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue, DropKeyDropKey, DropKeyWhereValueEqDropKeyWhereValueEq, DropRecordWhereValueEqDropRecordWhereValueEq, DuplicateKeyValueToKeyDuplicateKeyValueToKey, FlattenFlatten, FlattenallFlattenAll, JqJQ, Map<String, Object>, MathMultiplyWithValueMathMultiplyWithValue, MutateTypeMutateType, MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq, MutateValueWhereKeyEqMutateValueWhereKeyEq, RenameKeyRenameKey, RenameKeyWhereValueEqRenameKeyWhereValueEq, UtcTimestampTimestamp");
    }

    /**
     * Get the actual instance, which can be the following:
     * AddAdd, CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue, DropKeyDropKey, DropKeyWhereValueEqDropKeyWhereValueEq, DropRecordWhereValueEqDropRecordWhereValueEq, DuplicateKeyValueToKeyDuplicateKeyValueToKey, FlattenFlatten, FlattenallFlattenAll, JqJQ, Map<String, Object>, MathMultiplyWithValueMathMultiplyWithValue, MutateTypeMutateType, MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq, MutateValueWhereKeyEqMutateValueWhereKeyEq, RenameKeyRenameKey, RenameKeyWhereValueEqRenameKeyWhereValueEq, UtcTimestampTimestamp
     *
     * @return The actual instance (AddAdd, CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue, DropKeyDropKey, DropKeyWhereValueEqDropKeyWhereValueEq, DropRecordWhereValueEqDropRecordWhereValueEq, DuplicateKeyValueToKeyDuplicateKeyValueToKey, FlattenFlatten, FlattenallFlattenAll, JqJQ, Map<String, Object>, MathMultiplyWithValueMathMultiplyWithValue, MutateTypeMutateType, MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq, MutateValueWhereKeyEqMutateValueWhereKeyEq, RenameKeyRenameKey, RenameKeyWhereValueEqRenameKeyWhereValueEq, UtcTimestampTimestamp)
     */
    @SuppressWarnings("unchecked")
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `AddAdd`. If the actual instance is not `AddAdd`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AddAdd`
     * @throws ClassCastException if the instance is not `AddAdd`
     */
    public AddAdd getAddAdd() throws ClassCastException {
        return (AddAdd)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue`. If the actual instance is not `CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue`
     * @throws ClassCastException if the instance is not `CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue`
     */
    public CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue getCreateKeyValueIfKeyValueCreateKeyValueIfKeyValue() throws ClassCastException {
        return (CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DropKeyDropKey`. If the actual instance is not `DropKeyDropKey`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DropKeyDropKey`
     * @throws ClassCastException if the instance is not `DropKeyDropKey`
     */
    public DropKeyDropKey getDropKeyDropKey() throws ClassCastException {
        return (DropKeyDropKey)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DropKeyWhereValueEqDropKeyWhereValueEq`. If the actual instance is not `DropKeyWhereValueEqDropKeyWhereValueEq`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DropKeyWhereValueEqDropKeyWhereValueEq`
     * @throws ClassCastException if the instance is not `DropKeyWhereValueEqDropKeyWhereValueEq`
     */
    public DropKeyWhereValueEqDropKeyWhereValueEq getDropKeyWhereValueEqDropKeyWhereValueEq() throws ClassCastException {
        return (DropKeyWhereValueEqDropKeyWhereValueEq)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DropRecordWhereValueEqDropRecordWhereValueEq`. If the actual instance is not `DropRecordWhereValueEqDropRecordWhereValueEq`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DropRecordWhereValueEqDropRecordWhereValueEq`
     * @throws ClassCastException if the instance is not `DropRecordWhereValueEqDropRecordWhereValueEq`
     */
    public DropRecordWhereValueEqDropRecordWhereValueEq getDropRecordWhereValueEqDropRecordWhereValueEq() throws ClassCastException {
        return (DropRecordWhereValueEqDropRecordWhereValueEq)super.getActualInstance();
    }

    /**
     * Get the actual instance of `DuplicateKeyValueToKeyDuplicateKeyValueToKey`. If the actual instance is not `DuplicateKeyValueToKeyDuplicateKeyValueToKey`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `DuplicateKeyValueToKeyDuplicateKeyValueToKey`
     * @throws ClassCastException if the instance is not `DuplicateKeyValueToKeyDuplicateKeyValueToKey`
     */
    public DuplicateKeyValueToKeyDuplicateKeyValueToKey getDuplicateKeyValueToKeyDuplicateKeyValueToKey() throws ClassCastException {
        return (DuplicateKeyValueToKeyDuplicateKeyValueToKey)super.getActualInstance();
    }

    /**
     * Get the actual instance of `FlattenFlatten`. If the actual instance is not `FlattenFlatten`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FlattenFlatten`
     * @throws ClassCastException if the instance is not `FlattenFlatten`
     */
    public FlattenFlatten getFlattenFlatten() throws ClassCastException {
        return (FlattenFlatten)super.getActualInstance();
    }

    /**
     * Get the actual instance of `FlattenallFlattenAll`. If the actual instance is not `FlattenallFlattenAll`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `FlattenallFlattenAll`
     * @throws ClassCastException if the instance is not `FlattenallFlattenAll`
     */
    public FlattenallFlattenAll getFlattenallFlattenAll() throws ClassCastException {
        return (FlattenallFlattenAll)super.getActualInstance();
    }

    /**
     * Get the actual instance of `JqJQ`. If the actual instance is not `JqJQ`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `JqJQ`
     * @throws ClassCastException if the instance is not `JqJQ`
     */
    public JqJQ getJqJQ() throws ClassCastException {
        return (JqJQ)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MathMultiplyWithValueMathMultiplyWithValue`. If the actual instance is not `MathMultiplyWithValueMathMultiplyWithValue`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MathMultiplyWithValueMathMultiplyWithValue`
     * @throws ClassCastException if the instance is not `MathMultiplyWithValueMathMultiplyWithValue`
     */
    public MathMultiplyWithValueMathMultiplyWithValue getMathMultiplyWithValueMathMultiplyWithValue() throws ClassCastException {
        return (MathMultiplyWithValueMathMultiplyWithValue)super.getActualInstance();
    }

    /**
     * Get the actual instance of `Map<String, Object>`. If the actual instance is not `Map<String, Object>`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `Map<String, Object>`
     * @throws ClassCastException if the instance is not `Map<String, Object>`
     */
    public Map<String, Object> getMapStringObject() throws ClassCastException {
        return (Map<String, Object>)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MutateTypeMutateType`. If the actual instance is not `MutateTypeMutateType`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MutateTypeMutateType`
     * @throws ClassCastException if the instance is not `MutateTypeMutateType`
     */
    public MutateTypeMutateType getMutateTypeMutateType() throws ClassCastException {
        return (MutateTypeMutateType)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MutateValueWhereKeyEqMutateValueWhereKeyEq`. If the actual instance is not `MutateValueWhereKeyEqMutateValueWhereKeyEq`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MutateValueWhereKeyEqMutateValueWhereKeyEq`
     * @throws ClassCastException if the instance is not `MutateValueWhereKeyEqMutateValueWhereKeyEq`
     */
    public MutateValueWhereKeyEqMutateValueWhereKeyEq getMutateValueWhereKeyEqMutateValueWhereKeyEq() throws ClassCastException {
        return (MutateValueWhereKeyEqMutateValueWhereKeyEq)super.getActualInstance();
    }

    /**
     * Get the actual instance of `MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq`. If the actual instance is not `MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq`
     * @throws ClassCastException if the instance is not `MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq`
     */
    public MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq getMutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq() throws ClassCastException {
        return (MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq)super.getActualInstance();
    }

    /**
     * Get the actual instance of `RenameKeyRenameKey`. If the actual instance is not `RenameKeyRenameKey`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `RenameKeyRenameKey`
     * @throws ClassCastException if the instance is not `RenameKeyRenameKey`
     */
    public RenameKeyRenameKey getRenameKeyRenameKey() throws ClassCastException {
        return (RenameKeyRenameKey)super.getActualInstance();
    }

    /**
     * Get the actual instance of `RenameKeyWhereValueEqRenameKeyWhereValueEq`. If the actual instance is not `RenameKeyWhereValueEqRenameKeyWhereValueEq`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `RenameKeyWhereValueEqRenameKeyWhereValueEq`
     * @throws ClassCastException if the instance is not `RenameKeyWhereValueEqRenameKeyWhereValueEq`
     */
    public RenameKeyWhereValueEqRenameKeyWhereValueEq getRenameKeyWhereValueEqRenameKeyWhereValueEq() throws ClassCastException {
        return (RenameKeyWhereValueEqRenameKeyWhereValueEq)super.getActualInstance();
    }

    /**
     * Get the actual instance of `UtcTimestampTimestamp`. If the actual instance is not `UtcTimestampTimestamp`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `UtcTimestampTimestamp`
     * @throws ClassCastException if the instance is not `UtcTimestampTimestamp`
     */
    public UtcTimestampTimestamp getUtcTimestampTimestamp() throws ClassCastException {
        return (UtcTimestampTimestamp)super.getActualInstance();
    }

    /**
     * Validates the JSON Element and throws an exception if issues found
     *
     * @param jsonElement JSON Element
     * @throws IOException if the JSON Element is invalid with respect to RoutesTransformOperationArguments
     */
    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
        // validate oneOf schemas one by one
        int validCount = 0;
        ArrayList<String> errorMessages = new ArrayList<>();
        // validate the json string with AddAdd
        try {
            AddAdd.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for AddAdd failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue
        try {
            CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DropKeyDropKey
        try {
            DropKeyDropKey.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DropKeyDropKey failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DropKeyWhereValueEqDropKeyWhereValueEq
        try {
            DropKeyWhereValueEqDropKeyWhereValueEq.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DropKeyWhereValueEqDropKeyWhereValueEq failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DropRecordWhereValueEqDropRecordWhereValueEq
        try {
            DropRecordWhereValueEqDropRecordWhereValueEq.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DropRecordWhereValueEqDropRecordWhereValueEq failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with DuplicateKeyValueToKeyDuplicateKeyValueToKey
        try {
            DuplicateKeyValueToKeyDuplicateKeyValueToKey.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for DuplicateKeyValueToKeyDuplicateKeyValueToKey failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with FlattenFlatten
        try {
            FlattenFlatten.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for FlattenFlatten failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with FlattenallFlattenAll
        try {
            FlattenallFlattenAll.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for FlattenallFlattenAll failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with JqJQ
        try {
            JqJQ.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for JqJQ failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with MathMultiplyWithValueMathMultiplyWithValue
        try {
            MathMultiplyWithValueMathMultiplyWithValue.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for MathMultiplyWithValueMathMultiplyWithValue failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with Map<String, Object>
        try {
            if (!jsonElement.isJsonObject()) {
                throw new IllegalArgumentException(String.format("Expected json element to be a object type in the JSON string but got `%s`", jsonElement.toString()));
            }

            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for Map<String, Object> failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with MutateTypeMutateType
        try {
            MutateTypeMutateType.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for MutateTypeMutateType failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with MutateValueWhereKeyEqMutateValueWhereKeyEq
        try {
            MutateValueWhereKeyEqMutateValueWhereKeyEq.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for MutateValueWhereKeyEqMutateValueWhereKeyEq failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq
        try {
            MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with RenameKeyRenameKey
        try {
            RenameKeyRenameKey.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for RenameKeyRenameKey failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with RenameKeyWhereValueEqRenameKeyWhereValueEq
        try {
            RenameKeyWhereValueEqRenameKeyWhereValueEq.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for RenameKeyWhereValueEqRenameKeyWhereValueEq failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        // validate the json string with UtcTimestampTimestamp
        try {
            UtcTimestampTimestamp.validateJsonElement(jsonElement);
            validCount++;
        } catch (Exception e) {
            errorMessages.add(String.format("Deserialization for UtcTimestampTimestamp failed with `%s`.", e.getMessage()));
            // continue to the next one
        }
        if (validCount != 1) {
            throw new IOException(String.format("The JSON string is invalid for RoutesTransformOperationArguments with oneOf schemas: AddAdd, CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue, DropKeyDropKey, DropKeyWhereValueEqDropKeyWhereValueEq, DropRecordWhereValueEqDropRecordWhereValueEq, DuplicateKeyValueToKeyDuplicateKeyValueToKey, FlattenFlatten, FlattenallFlattenAll, JqJQ, Map<String, Object>, MathMultiplyWithValueMathMultiplyWithValue, MutateTypeMutateType, MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq, MutateValueWhereKeyEqMutateValueWhereKeyEq, RenameKeyRenameKey, RenameKeyWhereValueEqRenameKeyWhereValueEq, UtcTimestampTimestamp. %d class(es) match the result, expected 1. Detailed failure message for oneOf schemas: %s. JSON: %s", validCount, errorMessages, jsonElement.toString()));
        }
    }

    /**
     * Create an instance of RoutesTransformOperationArguments given an JSON string
     *
     * @param jsonString JSON string
     * @return An instance of RoutesTransformOperationArguments
     * @throws IOException if the JSON string is invalid with respect to RoutesTransformOperationArguments
     */
    public static RoutesTransformOperationArguments fromJson(String jsonString) throws IOException {
        return JSON.getGson().fromJson(jsonString, RoutesTransformOperationArguments.class);
    }

    /**
     * Convert an instance of RoutesTransformOperationArguments to an JSON string
     *
     * @return JSON string
     */
    public String toJson() {
        return JSON.getGson().toJson(this);
    }
}

