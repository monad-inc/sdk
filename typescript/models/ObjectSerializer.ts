export * from '../models/ActorsInfoSettingsConfig';
export * from '../models/AddAdd';
export * from '../models/AdminActivitySettingsConfig';
export * from '../models/AdminLogsSettingsConfig';
export * from '../models/AuditLogsSettingsConfig';
export * from '../models/Auth0Auth0TokenResponse';
export * from '../models/Auth0LoginRequest';
export * from '../models/AuthLogsSettingsConfig';
export * from '../models/AwsS3SettingsConfig';
export * from '../models/AzureActivityLogsSettingsConfig';
export * from '../models/ConditionInfo';
export * from '../models/CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue';
export * from '../models/DropKeyDropKey';
export * from '../models/DropKeyWhereValueEqDropKeyWhereValueEq';
export * from '../models/DropRecordWhereValueEqDropRecordWhereValueEq';
export * from '../models/DuplicateKeyValueToKeyDuplicateKeyValueToKey';
export * from '../models/FlattenFlatten';
export * from '../models/InputsConnectorMeta';
export * from '../models/JqJQ';
export * from '../models/MathMultiplyWithValueMathMultiplyWithValue';
export * from '../models/ModelsAPIKey';
export * from '../models/ModelsAPIKeyList';
export * from '../models/ModelsAPIKeyWithToken';
export * from '../models/ModelsComponentReference';
export * from '../models/ModelsConnectorMeta';
export * from '../models/ModelsDataUsage';
export * from '../models/ModelsInput';
export * from '../models/ModelsInputConfig';
export * from '../models/ModelsInputList';
export * from '../models/ModelsNodeComponent';
export * from '../models/ModelsOrganization';
export * from '../models/ModelsOrganizationList';
export * from '../models/ModelsOrganizationUser';
export * from '../models/ModelsOrganizationUserList';
export * from '../models/ModelsOutput';
export * from '../models/ModelsOutputConfig';
export * from '../models/ModelsOutputList';
export * from '../models/ModelsPagination';
export * from '../models/ModelsPipeline';
export * from '../models/ModelsPipelineConfigV2';
export * from '../models/ModelsPipelineEdge';
export * from '../models/ModelsPipelineEdgeCondition';
export * from '../models/ModelsPipelineEdgeConditions';
export * from '../models/ModelsPipelineList';
export * from '../models/ModelsPipelineNode';
export * from '../models/ModelsPipelineNodeMetrics';
export * from '../models/ModelsPipelineNodeMetricsValue';
export * from '../models/ModelsPipelineNodeStatus';
export * from '../models/ModelsPipelineStatus';
export * from '../models/ModelsQuota';
export * from '../models/ModelsQuotaList';
export * from '../models/ModelsRole';
export * from '../models/ModelsRoleList';
export * from '../models/ModelsSecretWithComponents';
export * from '../models/ModelsSecretWithComponentsList';
export * from '../models/ModelsTransform';
export * from '../models/ModelsTransformConfig';
export * from '../models/ModelsTransformList';
export * from '../models/ModelsTransformOperation';
export * from '../models/ModelsUser';
export * from '../models/ModelsUserList';
export * from '../models/MutateTypeMutateType';
export * from '../models/MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq';
export * from '../models/MutateValueWhereKeyEqMutateValueWhereKeyEq';
export * from '../models/OperationInformation';
export * from '../models/OutputsConnectorMeta';
export * from '../models/RenameKeyRenameKey';
export * from '../models/RenameKeyWhereValueEqRenameKeyWhereValueEq';
export * from '../models/ResponderErrorResponse';
export * from '../models/RoutesAddUserToOrganizationRequest';
export * from '../models/RoutesCreateOrganizationRequest';
export * from '../models/RoutesCreateRoleRequest';
export * from '../models/RoutesCreateTransformRequest';
export * from '../models/RoutesGetInputResponse';
export * from '../models/RoutesGetOutputResponse';
export * from '../models/RoutesGetTransformResponse';
export * from '../models/RoutesInviteUserToOrganizationRequest';
export * from '../models/RoutesTransformConfig';
export * from '../models/RoutesTransformOperation';
export * from '../models/RoutesTransformOperationArguments';
export * from '../models/RoutesUpdateOrganizationRequest';
export * from '../models/RoutesUpdatePipelineRequest';
export * from '../models/RoutesUpdateRoleRequest';
export * from '../models/RoutesUpdateTransformRequest';
export * from '../models/RoutesUpdateUserInOrganizationRequest';
export * from '../models/RoutesV2ApplyTransformationRequest';
export * from '../models/RoutesV2ApplyTransformationResponse';
export * from '../models/RoutesV2CreateAPIKeyRequest';
export * from '../models/RoutesV2CreateInputRequest';
export * from '../models/RoutesV2CreateOrUpdateSecretRequest';
export * from '../models/RoutesV2CreateOutputRequest';
export * from '../models/RoutesV2CreatePipelineRequest';
export * from '../models/RoutesV2GenerateRecordRequest';
export * from '../models/RoutesV2GenerateRecordResponse';
export * from '../models/RoutesV2GetOrganizationSummaryResponse';
export * from '../models/RoutesV2ListTemplatesResponse';
export * from '../models/RoutesV2OrganizationOverview';
export * from '../models/RoutesV2PipelineRequestEdge';
export * from '../models/RoutesV2PipelineRequestNode';
export * from '../models/RoutesV2PipelineStatus';
export * from '../models/RoutesV2PipelineWithStatus';
export * from '../models/RoutesV2SecretResponse';
export * from '../models/RoutesV2SuccessResponse';
export * from '../models/RoutesV2UpdateAPIKeyRequest';
export * from '../models/RoutesV2UpdateInputRequest';
export * from '../models/RoutesV2UpdateOutputRequest';
export * from '../models/RoutesV2UpdatePipelineRequest';
export * from '../models/UtcTimestampTimestamp';
export * from '../models/V2OrganizationIdPipelinesPipelineIdNodeIdMetricsGet500Response';

import { ActorsInfoSettingsConfig } from '../models/ActorsInfoSettingsConfig';
import { AddAdd } from '../models/AddAdd';
import { AdminActivitySettingsConfig } from '../models/AdminActivitySettingsConfig';
import { AdminLogsSettingsConfig } from '../models/AdminLogsSettingsConfig';
import { AuditLogsSettingsConfig } from '../models/AuditLogsSettingsConfig';
import { Auth0Auth0TokenResponse } from '../models/Auth0Auth0TokenResponse';
import { Auth0LoginRequest } from '../models/Auth0LoginRequest';
import { AuthLogsSettingsConfig } from '../models/AuthLogsSettingsConfig';
import { AwsS3SettingsConfig } from '../models/AwsS3SettingsConfig';
import { AzureActivityLogsSettingsConfig } from '../models/AzureActivityLogsSettingsConfig';
import { ConditionInfo } from '../models/ConditionInfo';
import { CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue } from '../models/CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue';
import { DropKeyDropKey } from '../models/DropKeyDropKey';
import { DropKeyWhereValueEqDropKeyWhereValueEq } from '../models/DropKeyWhereValueEqDropKeyWhereValueEq';
import { DropRecordWhereValueEqDropRecordWhereValueEq } from '../models/DropRecordWhereValueEqDropRecordWhereValueEq';
import { DuplicateKeyValueToKeyDuplicateKeyValueToKey } from '../models/DuplicateKeyValueToKeyDuplicateKeyValueToKey';
import { FlattenFlatten } from '../models/FlattenFlatten';
import { InputsConnectorMeta } from '../models/InputsConnectorMeta';
import { JqJQ } from '../models/JqJQ';
import { MathMultiplyWithValueMathMultiplyWithValue } from '../models/MathMultiplyWithValueMathMultiplyWithValue';
import { ModelsAPIKey } from '../models/ModelsAPIKey';
import { ModelsAPIKeyList } from '../models/ModelsAPIKeyList';
import { ModelsAPIKeyWithToken } from '../models/ModelsAPIKeyWithToken';
import { ModelsComponentReference } from '../models/ModelsComponentReference';
import { ModelsConnectorMeta } from '../models/ModelsConnectorMeta';
import { ModelsDataUsage } from '../models/ModelsDataUsage';
import { ModelsInput } from '../models/ModelsInput';
import { ModelsInputConfig } from '../models/ModelsInputConfig';
import { ModelsInputList } from '../models/ModelsInputList';
import { ModelsNodeComponent } from '../models/ModelsNodeComponent';
import { ModelsOrganization } from '../models/ModelsOrganization';
import { ModelsOrganizationList } from '../models/ModelsOrganizationList';
import { ModelsOrganizationUser } from '../models/ModelsOrganizationUser';
import { ModelsOrganizationUserList } from '../models/ModelsOrganizationUserList';
import { ModelsOutput } from '../models/ModelsOutput';
import { ModelsOutputConfig } from '../models/ModelsOutputConfig';
import { ModelsOutputList } from '../models/ModelsOutputList';
import { ModelsPagination } from '../models/ModelsPagination';
import { ModelsPipeline } from '../models/ModelsPipeline';
import { ModelsPipelineConfigV2 } from '../models/ModelsPipelineConfigV2';
import { ModelsPipelineEdge } from '../models/ModelsPipelineEdge';
import { ModelsPipelineEdgeCondition } from '../models/ModelsPipelineEdgeCondition';
import { ModelsPipelineEdgeConditions } from '../models/ModelsPipelineEdgeConditions';
import { ModelsPipelineList } from '../models/ModelsPipelineList';
import { ModelsPipelineNode } from '../models/ModelsPipelineNode';
import { ModelsPipelineNodeMetrics } from '../models/ModelsPipelineNodeMetrics';
import { ModelsPipelineNodeMetricsValue } from '../models/ModelsPipelineNodeMetricsValue';
import { ModelsPipelineNodeStatus } from '../models/ModelsPipelineNodeStatus';
import { ModelsPipelineStatus } from '../models/ModelsPipelineStatus';
import { ModelsQuota } from '../models/ModelsQuota';
import { ModelsQuotaList } from '../models/ModelsQuotaList';
import { ModelsRole } from '../models/ModelsRole';
import { ModelsRoleList } from '../models/ModelsRoleList';
import { ModelsSecretWithComponents } from '../models/ModelsSecretWithComponents';
import { ModelsSecretWithComponentsList } from '../models/ModelsSecretWithComponentsList';
import { ModelsTransform } from '../models/ModelsTransform';
import { ModelsTransformConfig } from '../models/ModelsTransformConfig';
import { ModelsTransformList } from '../models/ModelsTransformList';
import { ModelsTransformOperation } from '../models/ModelsTransformOperation';
import { ModelsUser } from '../models/ModelsUser';
import { ModelsUserList } from '../models/ModelsUserList';
import { MutateTypeMutateType } from '../models/MutateTypeMutateType';
import { MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq } from '../models/MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq';
import { MutateValueWhereKeyEqMutateValueWhereKeyEq } from '../models/MutateValueWhereKeyEqMutateValueWhereKeyEq';
import { OperationInformation } from '../models/OperationInformation';
import { OutputsConnectorMeta } from '../models/OutputsConnectorMeta';
import { RenameKeyRenameKey } from '../models/RenameKeyRenameKey';
import { RenameKeyWhereValueEqRenameKeyWhereValueEq } from '../models/RenameKeyWhereValueEqRenameKeyWhereValueEq';
import { ResponderErrorResponse } from '../models/ResponderErrorResponse';
import { RoutesAddUserToOrganizationRequest } from '../models/RoutesAddUserToOrganizationRequest';
import { RoutesCreateOrganizationRequest } from '../models/RoutesCreateOrganizationRequest';
import { RoutesCreateRoleRequest } from '../models/RoutesCreateRoleRequest';
import { RoutesCreateTransformRequest } from '../models/RoutesCreateTransformRequest';
import { RoutesGetInputResponse } from '../models/RoutesGetInputResponse';
import { RoutesGetOutputResponse } from '../models/RoutesGetOutputResponse';
import { RoutesGetTransformResponse } from '../models/RoutesGetTransformResponse';
import { RoutesInviteUserToOrganizationRequest } from '../models/RoutesInviteUserToOrganizationRequest';
import { RoutesTransformConfig } from '../models/RoutesTransformConfig';
import { RoutesTransformOperation } from '../models/RoutesTransformOperation';
import { RoutesTransformOperationArgumentsClass } from '../models/RoutesTransformOperationArguments';
import { RoutesUpdateOrganizationRequest } from '../models/RoutesUpdateOrganizationRequest';
import { RoutesUpdatePipelineRequest } from '../models/RoutesUpdatePipelineRequest';
import { RoutesUpdateRoleRequest } from '../models/RoutesUpdateRoleRequest';
import { RoutesUpdateTransformRequest } from '../models/RoutesUpdateTransformRequest';
import { RoutesUpdateUserInOrganizationRequest } from '../models/RoutesUpdateUserInOrganizationRequest';
import { RoutesV2ApplyTransformationRequest } from '../models/RoutesV2ApplyTransformationRequest';
import { RoutesV2ApplyTransformationResponse } from '../models/RoutesV2ApplyTransformationResponse';
import { RoutesV2CreateAPIKeyRequest } from '../models/RoutesV2CreateAPIKeyRequest';
import { RoutesV2CreateInputRequest } from '../models/RoutesV2CreateInputRequest';
import { RoutesV2CreateOrUpdateSecretRequest } from '../models/RoutesV2CreateOrUpdateSecretRequest';
import { RoutesV2CreateOutputRequest } from '../models/RoutesV2CreateOutputRequest';
import { RoutesV2CreatePipelineRequest } from '../models/RoutesV2CreatePipelineRequest';
import { RoutesV2GenerateRecordRequest } from '../models/RoutesV2GenerateRecordRequest';
import { RoutesV2GenerateRecordResponse } from '../models/RoutesV2GenerateRecordResponse';
import { RoutesV2GetOrganizationSummaryResponse } from '../models/RoutesV2GetOrganizationSummaryResponse';
import { RoutesV2ListTemplatesResponse } from '../models/RoutesV2ListTemplatesResponse';
import { RoutesV2OrganizationOverview } from '../models/RoutesV2OrganizationOverview';
import { RoutesV2PipelineRequestEdge } from '../models/RoutesV2PipelineRequestEdge';
import { RoutesV2PipelineRequestNode } from '../models/RoutesV2PipelineRequestNode';
import { RoutesV2PipelineStatus } from '../models/RoutesV2PipelineStatus';
import { RoutesV2PipelineWithStatus } from '../models/RoutesV2PipelineWithStatus';
import { RoutesV2SecretResponse } from '../models/RoutesV2SecretResponse';
import { RoutesV2SuccessResponse } from '../models/RoutesV2SuccessResponse';
import { RoutesV2UpdateAPIKeyRequest } from '../models/RoutesV2UpdateAPIKeyRequest';
import { RoutesV2UpdateInputRequest } from '../models/RoutesV2UpdateInputRequest';
import { RoutesV2UpdateOutputRequest } from '../models/RoutesV2UpdateOutputRequest';
import { RoutesV2UpdatePipelineRequest } from '../models/RoutesV2UpdatePipelineRequest';
import { UtcTimestampTimestamp } from '../models/UtcTimestampTimestamp';
import { V2OrganizationIdPipelinesPipelineIdNodeIdMetricsGet500ResponseClass } from '../models/V2OrganizationIdPipelinesPipelineIdNodeIdMetricsGet500Response';

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

let enumsMap: Set<string> = new Set<string>([
]);

let typeMap: {[index: string]: any} = {
    "ActorsInfoSettingsConfig": ActorsInfoSettingsConfig,
    "AddAdd": AddAdd,
    "AdminActivitySettingsConfig": AdminActivitySettingsConfig,
    "AdminLogsSettingsConfig": AdminLogsSettingsConfig,
    "AuditLogsSettingsConfig": AuditLogsSettingsConfig,
    "Auth0Auth0TokenResponse": Auth0Auth0TokenResponse,
    "Auth0LoginRequest": Auth0LoginRequest,
    "AuthLogsSettingsConfig": AuthLogsSettingsConfig,
    "AwsS3SettingsConfig": AwsS3SettingsConfig,
    "AzureActivityLogsSettingsConfig": AzureActivityLogsSettingsConfig,
    "ConditionInfo": ConditionInfo,
    "CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue": CreateKeyValueIfKeyValueCreateKeyValueIfKeyValue,
    "DropKeyDropKey": DropKeyDropKey,
    "DropKeyWhereValueEqDropKeyWhereValueEq": DropKeyWhereValueEqDropKeyWhereValueEq,
    "DropRecordWhereValueEqDropRecordWhereValueEq": DropRecordWhereValueEqDropRecordWhereValueEq,
    "DuplicateKeyValueToKeyDuplicateKeyValueToKey": DuplicateKeyValueToKeyDuplicateKeyValueToKey,
    "FlattenFlatten": FlattenFlatten,
    "InputsConnectorMeta": InputsConnectorMeta,
    "JqJQ": JqJQ,
    "MathMultiplyWithValueMathMultiplyWithValue": MathMultiplyWithValueMathMultiplyWithValue,
    "ModelsAPIKey": ModelsAPIKey,
    "ModelsAPIKeyList": ModelsAPIKeyList,
    "ModelsAPIKeyWithToken": ModelsAPIKeyWithToken,
    "ModelsComponentReference": ModelsComponentReference,
    "ModelsConnectorMeta": ModelsConnectorMeta,
    "ModelsDataUsage": ModelsDataUsage,
    "ModelsInput": ModelsInput,
    "ModelsInputConfig": ModelsInputConfig,
    "ModelsInputList": ModelsInputList,
    "ModelsNodeComponent": ModelsNodeComponent,
    "ModelsOrganization": ModelsOrganization,
    "ModelsOrganizationList": ModelsOrganizationList,
    "ModelsOrganizationUser": ModelsOrganizationUser,
    "ModelsOrganizationUserList": ModelsOrganizationUserList,
    "ModelsOutput": ModelsOutput,
    "ModelsOutputConfig": ModelsOutputConfig,
    "ModelsOutputList": ModelsOutputList,
    "ModelsPagination": ModelsPagination,
    "ModelsPipeline": ModelsPipeline,
    "ModelsPipelineConfigV2": ModelsPipelineConfigV2,
    "ModelsPipelineEdge": ModelsPipelineEdge,
    "ModelsPipelineEdgeCondition": ModelsPipelineEdgeCondition,
    "ModelsPipelineEdgeConditions": ModelsPipelineEdgeConditions,
    "ModelsPipelineList": ModelsPipelineList,
    "ModelsPipelineNode": ModelsPipelineNode,
    "ModelsPipelineNodeMetrics": ModelsPipelineNodeMetrics,
    "ModelsPipelineNodeMetricsValue": ModelsPipelineNodeMetricsValue,
    "ModelsPipelineNodeStatus": ModelsPipelineNodeStatus,
    "ModelsPipelineStatus": ModelsPipelineStatus,
    "ModelsQuota": ModelsQuota,
    "ModelsQuotaList": ModelsQuotaList,
    "ModelsRole": ModelsRole,
    "ModelsRoleList": ModelsRoleList,
    "ModelsSecretWithComponents": ModelsSecretWithComponents,
    "ModelsSecretWithComponentsList": ModelsSecretWithComponentsList,
    "ModelsTransform": ModelsTransform,
    "ModelsTransformConfig": ModelsTransformConfig,
    "ModelsTransformList": ModelsTransformList,
    "ModelsTransformOperation": ModelsTransformOperation,
    "ModelsUser": ModelsUser,
    "ModelsUserList": ModelsUserList,
    "MutateTypeMutateType": MutateTypeMutateType,
    "MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq": MutateValueWhereKeyEqAndValueEqMutateValueWhereKeyEqAndValueEq,
    "MutateValueWhereKeyEqMutateValueWhereKeyEq": MutateValueWhereKeyEqMutateValueWhereKeyEq,
    "OperationInformation": OperationInformation,
    "OutputsConnectorMeta": OutputsConnectorMeta,
    "RenameKeyRenameKey": RenameKeyRenameKey,
    "RenameKeyWhereValueEqRenameKeyWhereValueEq": RenameKeyWhereValueEqRenameKeyWhereValueEq,
    "ResponderErrorResponse": ResponderErrorResponse,
    "RoutesAddUserToOrganizationRequest": RoutesAddUserToOrganizationRequest,
    "RoutesCreateOrganizationRequest": RoutesCreateOrganizationRequest,
    "RoutesCreateRoleRequest": RoutesCreateRoleRequest,
    "RoutesCreateTransformRequest": RoutesCreateTransformRequest,
    "RoutesGetInputResponse": RoutesGetInputResponse,
    "RoutesGetOutputResponse": RoutesGetOutputResponse,
    "RoutesGetTransformResponse": RoutesGetTransformResponse,
    "RoutesInviteUserToOrganizationRequest": RoutesInviteUserToOrganizationRequest,
    "RoutesTransformConfig": RoutesTransformConfig,
    "RoutesTransformOperation": RoutesTransformOperation,
    "RoutesTransformOperationArguments": RoutesTransformOperationArgumentsClass,
    "RoutesUpdateOrganizationRequest": RoutesUpdateOrganizationRequest,
    "RoutesUpdatePipelineRequest": RoutesUpdatePipelineRequest,
    "RoutesUpdateRoleRequest": RoutesUpdateRoleRequest,
    "RoutesUpdateTransformRequest": RoutesUpdateTransformRequest,
    "RoutesUpdateUserInOrganizationRequest": RoutesUpdateUserInOrganizationRequest,
    "RoutesV2ApplyTransformationRequest": RoutesV2ApplyTransformationRequest,
    "RoutesV2ApplyTransformationResponse": RoutesV2ApplyTransformationResponse,
    "RoutesV2CreateAPIKeyRequest": RoutesV2CreateAPIKeyRequest,
    "RoutesV2CreateInputRequest": RoutesV2CreateInputRequest,
    "RoutesV2CreateOrUpdateSecretRequest": RoutesV2CreateOrUpdateSecretRequest,
    "RoutesV2CreateOutputRequest": RoutesV2CreateOutputRequest,
    "RoutesV2CreatePipelineRequest": RoutesV2CreatePipelineRequest,
    "RoutesV2GenerateRecordRequest": RoutesV2GenerateRecordRequest,
    "RoutesV2GenerateRecordResponse": RoutesV2GenerateRecordResponse,
    "RoutesV2GetOrganizationSummaryResponse": RoutesV2GetOrganizationSummaryResponse,
    "RoutesV2ListTemplatesResponse": RoutesV2ListTemplatesResponse,
    "RoutesV2OrganizationOverview": RoutesV2OrganizationOverview,
    "RoutesV2PipelineRequestEdge": RoutesV2PipelineRequestEdge,
    "RoutesV2PipelineRequestNode": RoutesV2PipelineRequestNode,
    "RoutesV2PipelineStatus": RoutesV2PipelineStatus,
    "RoutesV2PipelineWithStatus": RoutesV2PipelineWithStatus,
    "RoutesV2SecretResponse": RoutesV2SecretResponse,
    "RoutesV2SuccessResponse": RoutesV2SuccessResponse,
    "RoutesV2UpdateAPIKeyRequest": RoutesV2UpdateAPIKeyRequest,
    "RoutesV2UpdateInputRequest": RoutesV2UpdateInputRequest,
    "RoutesV2UpdateOutputRequest": RoutesV2UpdateOutputRequest,
    "RoutesV2UpdatePipelineRequest": RoutesV2UpdatePipelineRequest,
    "UtcTimestampTimestamp": UtcTimestampTimestamp,
    "V2OrganizationIdPipelinesPipelineIdNodeIdMetricsGet500Response": V2OrganizationIdPipelinesPipelineIdNodeIdMetricsGet500ResponseClass,
}

type MimeTypeDescriptor = {
    type: string;
    subtype: string;
    subtypeTokens: string[];
};

/**
 * Every mime-type consists of a type, subtype, and optional parameters.
 * The subtype can be composite, including information about the content format.
 * For example: `application/json-patch+json`, `application/merge-patch+json`.
 *
 * This helper transforms a string mime-type into an internal representation.
 * This simplifies the implementation of predicates that in turn define common rules for parsing or stringifying
 * the payload.
 */
const parseMimeType = (mimeType: string): MimeTypeDescriptor => {
    const [type = '', subtype = ''] = mimeType.split('/');
    return {
        type,
        subtype,
        subtypeTokens: subtype.split('+'),
    };
};

type MimeTypePredicate = (mimeType: string) => boolean;

// This factory creates a predicate function that checks a string mime-type against defined rules.
const mimeTypePredicateFactory = (predicate: (descriptor: MimeTypeDescriptor) => boolean): MimeTypePredicate => (mimeType) => predicate(parseMimeType(mimeType));

// Use this factory when you need to define a simple predicate based only on type and, if applicable, subtype.
const mimeTypeSimplePredicateFactory = (type: string, subtype?: string): MimeTypePredicate => mimeTypePredicateFactory((descriptor) => {
    if (descriptor.type !== type) return false;
    if (subtype != null && descriptor.subtype !== subtype) return false;
    return true;
});

// Creating a set of named predicates that will help us determine how to handle different mime-types
const isTextLikeMimeType = mimeTypeSimplePredicateFactory('text');
const isJsonMimeType = mimeTypeSimplePredicateFactory('application', 'json');
const isJsonLikeMimeType = mimeTypePredicateFactory((descriptor) => descriptor.type === 'application' && descriptor.subtypeTokens.some((item) => item === 'json'));
const isOctetStreamMimeType = mimeTypeSimplePredicateFactory('application', 'octet-stream');
const isFormUrlencodedMimeType = mimeTypeSimplePredicateFactory('application', 'x-www-form-urlencoded');

// Defining a list of mime-types in the order of prioritization for handling.
const supportedMimeTypePredicatesWithPriority: MimeTypePredicate[] = [
    isJsonMimeType,
    isJsonLikeMimeType,
    isTextLikeMimeType,
    isOctetStreamMimeType,
    isFormUrlencodedMimeType,
];

const nullableSuffix = " | null";
const optionalSuffix = " | undefined";
const arrayPrefix = "Array<";
const arraySuffix = ">";
const mapPrefix = "{ [key: string]: ";
const mapSuffix = "; }";

export class ObjectSerializer {
    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap.has(expectedType)) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    let mapping = typeMap[expectedType].mapping;
                    if (mapping != undefined && mapping[discriminatorType]) {
                        return mapping[discriminatorType]; // use the type given in the discriminator
                    } else if(typeMap[discriminatorType]) {
                        return discriminatorType;
                    } else {
                        return expectedType; // discriminator did not map to a type
                    }
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string, format: string): any {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.endsWith(nullableSuffix)) {
            let subType: string = type.slice(0, -nullableSuffix.length); // Type | null => Type
            return ObjectSerializer.serialize(data, subType, format);
        } else if (type.endsWith(optionalSuffix)) {
            let subType: string = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
            return ObjectSerializer.serialize(data, subType, format);
        } else if (type.startsWith(arrayPrefix)) {
            let subType: string = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
            let transformedData: any[] = [];
            for (let date of data) {
                transformedData.push(ObjectSerializer.serialize(date, subType, format));
            }
            return transformedData;
        } else if (type.startsWith(mapPrefix)) {
            let subType: string = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
            let transformedData: { [key: string]: any } = {};
            for (let key in data) {
                transformedData[key] = ObjectSerializer.serialize(
                    data[key],
                    subType,
                    format,
                );
            }
            return transformedData;
        } else if (type === "Date") {
            if (format == "date") {
                let month = data.getMonth()+1
                month = month < 10 ? "0" + month.toString() : month.toString()
                let day = data.getDate();
                day = day < 10 ? "0" + day.toString() : day.toString();

                return data.getFullYear() + "-" + month + "-" + day;
            } else {
                return data.toISOString();
            }
        } else {
            if (enumsMap.has(type)) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // Get the actual type of this object
            type = this.findCorrectType(data, type);

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let attributeType of attributeTypes) {
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string, format: string): any {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.endsWith(nullableSuffix)) {
            let subType: string = type.slice(0, -nullableSuffix.length); // Type | null => Type
            return ObjectSerializer.deserialize(data, subType, format);
        } else if (type.endsWith(optionalSuffix)) {
            let subType: string = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
            return ObjectSerializer.deserialize(data, subType, format);
        } else if (type.startsWith(arrayPrefix)) {
            let subType: string = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
            let transformedData: any[] = [];
            for (let date of data) {
                transformedData.push(ObjectSerializer.deserialize(date, subType, format));
            }
            return transformedData;
        } else if (type.startsWith(mapPrefix)) {
            let subType: string = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
            let transformedData: { [key: string]: any } = {};
            for (let key in data) {
                transformedData[key] = ObjectSerializer.deserialize(
                    data[key],
                    subType,
                    format,
                );
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap.has(type)) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let attributeType of attributeTypes) {
                let value = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
                if (value !== undefined) {
                    instance[attributeType.name] = value;
                }
            }
            return instance;
        }
    }


    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    public static normalizeMediaType(mediaType: string | undefined): string | undefined {
        if (mediaType === undefined) {
            return undefined;
        }
        return (mediaType.split(";")[0] ?? '').trim().toLowerCase();
    }

    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    public static getPreferredMediaType(mediaTypes: Array<string>): string {
        /** According to OAS 3 we should default to json */
        if (mediaTypes.length === 0) {
            return "application/json";
        }

        const normalMediaTypes = mediaTypes.map(ObjectSerializer.normalizeMediaType);

        for (const predicate of supportedMimeTypePredicatesWithPriority) {
            for (const mediaType of normalMediaTypes) {
                if (mediaType != null && predicate(mediaType)) {
                    return mediaType;
                }
            }
        }

        throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
    }

    /**
     * Convert data to a string according the given media type
     */
    public static stringify(data: any, mediaType: string): string {
        if (isTextLikeMimeType(mediaType)) {
            return String(data);
        }

        if (isJsonLikeMimeType(mediaType)) {
            return JSON.stringify(data);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.stringify.");
    }

    /**
     * Parse data from a string according to the given media type
     */
    public static parse(rawData: string, mediaType: string | undefined) {
        if (mediaType === undefined) {
            throw new Error("Cannot parse content. No Content-Type defined.");
        }

        if (isTextLikeMimeType(mediaType)) {
            return rawData;
        }

        if (isJsonLikeMimeType(mediaType)) {
            return JSON.parse(rawData);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.parse.");
    }
}
